(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{238:function(e,a,n){"use strict";n.r(a);var v=n(6),l=Object(v.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("blockquote",[n("p",[e._v("原理，使用，优缺点，怎么优化，横向对比竞品，扩展引申相同原理的技术，或者更进一步，有更好的解决方案。")])]),e._v(" "),n("blockquote",[n("p",[e._v("STAR 背景，点出问题，多种解决方法，为什么选这种，结果，还有更好的方法吗")])]),e._v(" "),n("h2",{attrs:{id:"_1-缩小文件的搜索范围"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-缩小文件的搜索范围"}},[e._v("#")]),e._v(" 1 缩小文件的搜索范围")]),e._v(" "),n("h3",{attrs:{id:"_1-1优化loader配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1优化loader配置"}},[e._v("#")]),e._v(" 1-1优化Loader配置")]),e._v(" "),n("blockquote",[n("p",[e._v("loader相关的知识，请查看文章："),n("strong",[e._v("什么webpack的loader")])])]),e._v(" "),n("p",[e._v("由于Loader对文件的转换操作很耗时，所以需要让尽可能少的文件被Loader处理。"),n("br"),e._v("\n我们可以通过以下3方面优化Loader配置：")]),e._v(" "),n("ul",[n("li",[e._v("（1）优化正则匹配")]),e._v(" "),n("li",[e._v("（2）通过cacheDirectory选项开启缓存")]),e._v(" "),n("li",[e._v("（3）通过include、exclude来减少被处理的文件。")])]),e._v(" "),n("p",[n("strong",[e._v("实践如下：")])]),e._v(" "),n("p",[e._v("项目原配置：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{\n  test: /\\.js$/,\n  loader: 'babel-loader',\n  include: [resolve('src'), resolve('test')]\n},\n")])])]),n("p",[e._v("优化后配置：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{\n  // 1、如果项目源码中只有js文件，就不要写成/\\.jsx?$/，以提升正则表达式的性能\n  test: /\\.js$/,\n  // 2、babel-loader支持缓存转换出的结果，通过cacheDirectory选项开启\n  loader: 'babel-loader?cacheDirectory',\n  // 3、只对项目根目录下的src 目录中的文件采用 babel-loader\n  include: [resolve('src')]\n},\n")])])]),n("h3",{attrs:{id:"_1-2-优化loader配置优化resolve-modules配置-resolve项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-优化loader配置优化resolve-modules配置-resolve项"}},[e._v("#")]),e._v(" 1-2.优化Loader配置优化resolve.modules配置（resolve项）")]),e._v(" "),n("p",[n("code",[e._v("resolve.modules")]),e._v(" 用于配置Webpack去哪些"),n("code",[e._v("目录")]),e._v("下寻找"),n("code",[e._v("第三方模块")]),e._v("。")]),e._v(" "),n("p",[e._v("resolve.modules的默认值是"),n("code",[e._v("［node modules］")]),e._v("，含义是"),n("code",[e._v("先去当前目录")]),e._v("的"),n("code",[e._v("/node modules")]),e._v("目录下去找我们想找的"),n("code",[e._v("模块")]),e._v("，如果没找到，就去"),n("code",[e._v("上一级")]),e._v("目录"),n("code",[e._v("../node modules")]),e._v("中找，再没有就去"),n("code",[e._v("../ .. /node modules")]),e._v("中找，以此类推")]),e._v(" "),n("p",[e._v("这和Node.js的模块寻找机制很相似。当安装的"),n("code",[e._v("第三方模块")]),e._v("都放在项目"),n("code",[e._v("根目录的./node modules")]),e._v("目录下时，就没有必要按照默认的方式去一层层地寻找，可以指明存放"),n("code",[e._v("第三方模块的绝对路径")]),e._v("，以减少寻找。")]),e._v(" "),n("p",[n("strong",[e._v("优化后配置：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("resolve: {\n// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤\nmodules: [path.resolve(__dirname,'node_modules')]\n},\n")])])]),n("h3",{attrs:{id:"_1-3-优化resolve-alias配置-resolve项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-优化resolve-alias配置-resolve项"}},[e._v("#")]),e._v(" 1-3.优化resolve.alias配置（resolve项）")]),e._v(" "),n("p",[n("code",[e._v("resolve.alias")]),e._v("配置项通过"),n("code",[e._v("别名")]),e._v("来将"),n("code",[e._v("原导入路径")]),e._v("映射成一个"),n("code",[e._v("新的导入路径")]),e._v("。")]),e._v(" "),n("p",[n("strong",[e._v("如项目中的配置使用：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("alias: {\n  '@': resolve('src'),\n},\n// 通过以上的配置，引用src底下的common.js文件，就可以直接这么写\nimport common from '@/common.js';//相当于 import common from 'src/common.js'\n")])])]),n("h3",{attrs:{id:"_1-4-优化resolve-extensions配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-优化resolve-extensions配置"}},[e._v("#")]),e._v(" 1-4. 优化resolve.extensions配置")]),e._v(" "),n("p",[e._v("在导入语句"),n("code",[e._v("没带文件后缀")]),e._v("时，Webpack 会在"),n("code",[e._v("自动带上后缀")]),e._v("后去"),n("code",[e._v("尝试询问文件是否存在")]),e._v("。默认是："),n("code",[e._v("extensions :['. js ','. json ']")]),e._v(" 。")]),e._v(" "),n("ul",[n("li",[e._v("也就是说，当遇到"),n("code",[e._v("require ( '. /data '）")]),e._v("这样的导入语句时，Webpack会先去寻找"),n("code",[e._v("./data .js")]),e._v("文件")]),e._v(" "),n("li",[e._v("如果该文件不存在，就去寻找"),n("code",[e._v("./data.json")]),e._v(" 文件，如果还是找不到就报错。")]),e._v(" "),n("li",[e._v("如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以 resolve .extensions 的配置也会影响到"),n("code",[e._v("构建的性能")]),e._v("。")])]),e._v(" "),n("p",[n("strong",[e._v("优化措施：")])]),e._v(" "),n("ul",[n("li",[n("code",[e._v("后缀尝试列表")]),e._v("要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中。")]),e._v(" "),n("li",[e._v("频率出现"),n("code",[e._v("最高")]),e._v("的文件后缀要"),n("code",[e._v("优先放在最前面")]),e._v("，以做到尽快退出寻找过程。")]),e._v(" "),n("li",[e._v("在源码中写"),n("code",[e._v("导入语句")]),e._v("时，要尽可能"),n("code",[e._v("带上后缀")]),e._v("，从而可以避免寻找过程。例如在确定的情况下将 "),n("code",[e._v("require('. /data ')")]),e._v("写成"),n("code",[e._v("require(' /data.json')")]),e._v("，可以结合enforceExtension 和 enforceModuleExtension开启使用来强制开发者遵守这条优化")])]),e._v(" "),n("h4",{attrs:{id:"_1-5-优化resolve-noparse配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-优化resolve-noparse配置"}},[e._v("#")]),e._v(" 1-5. 优化resolve.noParse配置")]),e._v(" "),n("p",[n("code",[e._v("noParse")]),e._v("配置项可以让"),n("code",[e._v("Webpack忽略")]),e._v("对部分"),n("code",[e._v("没采用模块化")]),e._v("的文件的"),n("code",[e._v("递归解析和处理")]),e._v("，这 样做的好处是能提高构建性能。")]),e._v(" "),n("p",[e._v("原因是一些库如"),n("code",[e._v("jQuery、ChartJS")]),e._v("庞大又"),n("code",[e._v("没有采用模块化标准")]),e._v("，让Webpack去"),n("code",[e._v("解析")]),e._v("这些文件既"),n("code",[e._v("耗时又没有意义")]),e._v("。")]),e._v(" "),n("p",[e._v("noParse是可选的配置项，类型需要是"),n("code",[e._v("RegExp 、[RegExp]、function")]),e._v("中的一种。")]),e._v(" "),n("p",[n("strong",[e._v("例如，若想要忽略jQuery 、ChartJS ，则优化配置如下：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 1. 使用正则表达式 \nnoParse: /jquerylchartjs/ \n// 2. 使用函数，从 Webpack3.0.0开始支持 \nnoParse: (content)=> { \n// 返回true或false \nreturn /jquery|chartjs/.test(content); \n}\n")])])]),n("h2",{attrs:{id:"_2-减少冗余代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-减少冗余代码"}},[e._v("#")]),e._v(" 2. 减少冗余代码")]),e._v(" "),n("p",[n("code",[e._v("babel-plugin-transform-runtime")]),e._v(" 是"),n("code",[e._v("Babel")]),e._v("官方提供的一个"),n("code",[e._v("插件")]),e._v("，作用是减少冗余的代码 。")]),e._v(" "),n("p",[e._v("Babel在将"),n("code",[e._v("ES6代码转换")]),e._v("成"),n("code",[e._v("ES5代码")]),e._v("时，通常需要一些由"),n("code",[e._v("ES5编写")]),e._v("的"),n("code",[e._v("辅助函数")]),e._v("来完成新语法的实现。")]),e._v(" "),n("p",[e._v("例如在转换ES6的 "),n("code",[e._v("class")]),e._v(" 语法时会在"),n("code",[e._v("转换后")]),e._v("的 "),n("code",[e._v("ES5")]),e._v(" 代码里注入 extent 辅助函数用于实现继承。")]),e._v(" "),n("p",[e._v("并且babel 默认会将这些辅助函数"),n("code",[e._v("内联")]),e._v("到"),n("code",[e._v("每一个 js 文件")]),e._v("里，这样文件多的时候，项目就会很大。")]),e._v(" "),n("p",[e._v("所以 babel 提供了 babel-plugin-transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，然后通过导入语句引用进来，从而减小babel编译出来的代码的文件大小。")]),e._v(" "),n("h2",{attrs:{id:"_3-使用happypack多进程解析和处理文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用happypack多进程解析和处理文件"}},[e._v("#")]),e._v(" 3. 使用HappyPack多进程解析和处理文件")]),e._v(" "),n("p",[e._v("由于有"),n("code",[e._v("大量文件")]),e._v("需要"),n("code",[e._v("解析和处理")]),e._v("，所以"),n("code",[e._v("构建")]),e._v("是"),n("code",[e._v("文件读写")]),e._v("和"),n("code",[e._v("计算密集型")]),e._v("的操作，特别是当文件数量变多后，Webpack构建慢的问题会显得更为严重。\n运行在 Node.之上的Webpack是"),n("code",[e._v("单线程模型")]),e._v("的（webpack的运行依赖于node的环境，没有node是不能打包的，所以Webpack也是单线程的），也就是说Webpack需要一个一个地处理任务，不能同时处理多个任务。")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/amireh/happypack",target:"_blank",rel:"noopener noreferrer"}},[e._v("Happy Pack"),n("OutboundLink")],1),e._v(" 就能让Webpack做到这一点，它将"),n("code",[e._v("任务分解")]),e._v("给"),n("code",[e._v("多个子进程")]),e._v("去"),n("code",[e._v("并发执行")]),e._v("，子进程"),n("code",[e._v("处理完")]),e._v("后再将"),n("code",[e._v("结果发送给主进程")]),e._v("。")]),e._v(" "),n("p",[n("strong",[e._v("项目中HappyPack使用配置：")])]),e._v(" "),n("ol",[n("li",[n("p",[e._v("HappyPack插件安装：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ npm i -D happypack\n")])])])]),e._v(" "),n("li",[n("p",[e._v("webpack.base.conf.js 文件对module.rules进行配置")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    module: {\n     rules: [\n      {\n        test: /\\.js$/,\n        // 将对.js 文件的处理转交给 id 为 babel 的HappyPack实例\n          use:['happypack/loader?id=babel'],\n          include: [resolve('src'), resolve('test'),   \n            resolve('node_modules/webpack-dev-server/client')],\n        // 排除第三方插件\n          exclude:path.resolve(__dirname,'node_modules'),\n        },\n        {\n          test: /\\.vue$/,\n          use: ['happypack/loader?id=vue'],\n        },\n      ]\n    },\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("webpack.prod.conf.js 文件进行配置")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    const HappyPack = require('happypack');\n    // 构造出共享进程池，在进程池中包含5个子进程\n    const HappyPackThreadPool = HappyPack.ThreadPool({size:5});\n    plugins: [\n       new HappyPack({\n         // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件\n         id:'vue',\n         loaders:[\n           {\n             loader:'vue-loader',\n             options: vueLoaderConfig\n           }\n         ],\n         threadPool: HappyPackThreadPool,\n       }),\n\n       new HappyPack({\n         // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件\n         id:'babel',\n         // 如何处理.js文件，用法和Loader配置中一样\n         loaders:['babel-loader?cacheDirectory'],\n         threadPool: HappyPackThreadPool,\n       }),\n    ]\n")])])]),n("h2",{attrs:{id:"_4-使用paralleluglifyplugin多进程压缩代码文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-使用paralleluglifyplugin多进程压缩代码文件"}},[e._v("#")]),e._v(" 4. 使用ParallelUglifyPlugin多进程压缩代码文件")]),e._v(" "),n("p",[e._v("由于压缩JavaScript 代码时，需要先将代码"),n("code",[e._v("解析")]),e._v("成用 Object 抽象表示的 "),n("code",[e._v("AST")]),e._v(" 语法树，再去应用各种规则分析和处理AST ，所以导致这个过程的计算量巨大，耗时非常多。")]),e._v(" "),n("p",[e._v("当Webpack有多个JavaScript 文件需要输出和压缩时，原本会使用"),n("code",[e._v("UglifyJS")]),e._v("去一个一个"),n("code",[e._v("压缩再输出")]),e._v("。如果使用ParallelUglifyPlugin会开启"),n("code",[e._v("多个子进程")]),e._v("，将对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过UglifyJS去压缩代码，但是变成了"),n("code",[e._v("并行执行")]),e._v("。")]),e._v(" "),n("p",[e._v("所以 ParallelUglify Plugin能更快地完成对多个文件的压缩工作。")]),e._v(" "),n("p",[n("strong",[e._v("项目中ParallelUglifyPlugin使用配置：")])]),e._v(" "),n("ol",[n("li",[e._v("ParallelUglifyPlugin插件安装：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("     $ npm i -D webpack-parallel-uglify-plugin\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("webpack.prod.conf.js 文件进行配置")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    const ParallelUglifyPlugin =require('webpack-parallel-uglify-plugin');\n    plugins: [\n    new ParallelUglifyPlugin({\n      cacheDir: '.cache/',\n      uglifyJs:{\n        compress: {\n          warnings: false\n        },\n        sourceMap: true\n      }\n     }),\n    ]\n")])])]),n("h2",{attrs:{id:"_5-使用自动刷新"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-使用自动刷新"}},[e._v("#")]),e._v(" 5. 使用自动刷新")]),e._v(" "),n("p",[e._v("借助自动化的手段，在监听到本地源码文件发生变化时，"),n("code",[e._v("自动重新构建")]),e._v("出"),n("code",[e._v("可运行")]),e._v("的代码后"),n("code",[e._v("再控制")]),e._v("浏览器刷新。")]),e._v(" "),n("p",[e._v("Webpack将这些功能都"),n("code",[e._v("内置")]),e._v("了，并且提供了多种方案供我们选择。")]),e._v(" "),n("p",[n("strong",[e._v("项目中自动刷新的配置：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("devServer: {\n  watchOptions: {\n    // 不监听的文件或文件夹，支持正则匹配\n    ignored: /node_modules/,\n    // 监听到变化后等300ms再去执行动作\n    aggregateTimeout: 300,\n    // 默认每秒询问1000次\n    poll: 1000\n  }\n},\n")])])]),n("p",[n("strong",[e._v("相关优化措施：")])]),e._v(" "),n("ul",[n("li",[e._v("配置忽略一些不监听的一些文件，如：node_modules。")]),e._v(" "),n("li",[e._v("watchOptions.aggregateTirneout 的值越大性能越好，因为这能降低重新构建的频率。")]),e._v(" "),n("li",[e._v("watchOptions.poll 的值越小越好，因为这能降低检查的频率。")])]),e._v(" "),n("h2",{attrs:{id:"_6-开启模块热替换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-开启模块热替换"}},[e._v("#")]),e._v(" 6. 开启模块热替换")]),e._v(" "),n("p",[e._v("DevServer 还支持一种叫做模块热替换（ Hot Module Replacement ）的技术可在不刷新整个网页的情况下做到超灵敏实时预览。")]),e._v(" "),n("p",[e._v("原理是在一个"),n("code",[e._v("源码")]),e._v("发生"),n("code",[e._v("变化")]),e._v("时，只需"),n("code",[e._v("重新编译")]),e._v("发生"),n("code",[e._v("变化的模块")]),e._v("，再用"),n("code",[e._v("新输出")]),e._v("的模块"),n("code",[e._v("替换")]),e._v("掉浏览器中对应的"),n("code",[e._v("老模块")]),e._v(" 。")]),e._v(" "),n("p",[e._v("模块热替换技术在很大程度上提升了开发效率和体验 。 \n"),n("strong",[e._v("项目中模块热替换的配置：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("devServer: {\n  hot: true,\n},\nplugins: [\n  new webpack.HotModuleReplacementPlugin(),\n// 显示被替换模块的名称\n  new webpack.NamedModulesPlugin(), // HMR shows correct file names\n]\n")])])]),n("h2",{attrs:{id:"_7-提取公共代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-提取公共代码"}},[e._v("#")]),e._v(" 7. 提取公共代码")]),e._v(" "),n("p",[e._v("如果每个页面的代码都将这些公共的部分包含进去，则会造成以下问题 ：")]),e._v(" "),n("ol",[n("li",[e._v("相同的资源被重复加载，浪费用户的流量和服务器的成本。")]),e._v(" "),n("li",[e._v("每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。")])]),e._v(" "),n("p",[e._v("如果将多个页面的公共代码抽离成单独的文件，就能优化以上问题 。")]),e._v(" "),n("p",[e._v("Webpack内置了专门用于"),n("code",[e._v("提取多个Chunk")]),e._v("中的"),n("code",[e._v("公共部分")]),e._v("的插件"),n("code",[e._v("CommonsChunkPlugin")]),e._v("。")]),e._v(" "),n("p",[n("strong",[e._v("CommonsChunkPlugin的配置属性：")])]),e._v(" "),n("ul",[n("li",[e._v("name：可以是已经存在的chunk（一般指入口文件）对应的name，那么就会把公共模块代码合并到这个chunk上；否则，会创建名字为name的commons chunk进行合并")]),e._v(" "),n("li",[e._v("filename：指定commons chunk的文件名")]),e._v(" "),n("li",[e._v("chunks：指定source chunk，即指定从哪些chunk当中去找公共模块，省略该选项的时候，默认就是entry chunks")]),e._v(" "),n("li",[e._v("minChunks：既可以是数字，也可以是函数，还可以是Infinity，具体用法和区别下面会说")])]),e._v(" "),n("p",[n("strong",[e._v("实例：")]),e._v("\n分离出第三方库、自定义公共模块、webpack运行文件，first.js和second.js都引入了jquery和common.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const path = require(\"path\");\nconst webpack = require(\"webpack\");\nconst packagejson = require(\"./package.json\");\n\nconst config = {\n    entry: {\n        first: './src/first.js',\n        second: './src/second.js',\n        vendor: Object.keys(packagejson.dependencies)//获取生产环境依赖的库\n    },\n    output: {\n        path: path.resolve(__dirname,'./dist'),\n        filename: '[name].js'\n    },\n    plugins: [\n        new webpack.optimize.CommonsChunkPlugin({\n            name: 'vendor',\n            filename: '[name].js'\n        }),\n    ]\n}\n\nmodule.exports = config;\n")])])]),n("p",[e._v("查看dist目录下，新增了一个vendor.js的文件")]),e._v(" "),n("p",[n("a",{attrs:{"data-fancybox":"",title:"打包图片",href:"/loader3.webp"}},[n("img",{attrs:{src:"/loader3.webp",alt:"order"}})]),e._v("\n此时：first.js和second.js文件中依赖的jquery和common.js都被打包进vendor.js中，同时还有webpack的运行文件。")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000012828879",target:"_blank",rel:"noopener noreferrer"}},[e._v("详情访问此文章"),n("OutboundLink")],1)]),e._v(" "),n("h3",{attrs:{id:"_8-通过webpack-bundle-analyzer分析代码包的大小"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-通过webpack-bundle-analyzer分析代码包的大小"}},[e._v("#")]),e._v(" 8. 通过webpack-bundle-analyzer分析代码包的大小")]),e._v(" "),n("blockquote",[n("p",[e._v("它可以直观分析打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项，文件是否重复，压缩后大小如何，针对这些，我们可以进行文件分割等操作。")])]),e._v(" "),n("ol",[n("li",[e._v("安装依赖")])]),e._v(" "),n("p",[e._v("首先安装webpack-bundle-analyzer")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm install --save-dev webpack-bundle-analyzer\n")])])]),n("p",[e._v("大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住。\ncross-env能跨平台地设置及使用环境变量")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm install --save-dev cross-env\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("配置webpack.config.js文件\n在webpack.config.js中配置以下代码")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("if (config.build.bundleAnalyzerReport) {\n    const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n    /*\n    module.exports = {\n        plugins: [\n            new BundleAnalyzerPlugin()\n        ]\n    }*/\n    webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("运行")])]),e._v(" "),n("p",[e._v("3.1 开发环境下运行")]),e._v(" "),n("p",[e._v("直接启动项目：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm run start 则会自动启动项目页面和分析页面（127.0.0.1:8888 默认地址和端口号）\n")])])]),n("p",[e._v("3.2 打包后运行")]),e._v(" "),n("p",[e._v("首先配置package.json")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('"scripts": {\n    "analyz": "cross-env NODE_ENV=production npm_config_report=true npm run build"\n}\n')])])]),n("p",[e._v("运行命令：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm run analyz\n")])])]),n("p",[e._v("项目打包完毕后会自动启动分析页面（127.0.0.1:8888 默认地址和端口号）")]),e._v(" "),n("h2",{attrs:{id:"_9-dll-plugin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-dll-plugin"}},[e._v("#")]),e._v(" 9. DLL  Plugin")]),e._v(" "),n("p",[e._v("在引入一些第三方模块时，例如Vue、React等，这些框架的文件一般都是不会修改的，")]),e._v(" "),n("p",[e._v("而每次打包都需要去解析他们，就会影响打包速度，就算是做了拆分，也只是提高了上线后的用户访问速度，并不会提高构建速度，所以如果需要提高构建速度，应该使用"),n("code",[e._v("动态链接库")]),e._v("的方式，类似"),n("code",[e._v("windows")]),e._v("的"),n("code",[e._v("dll文件")])]),e._v(" "),n("p",[e._v("借助"),n("code",[e._v("DLLPlugin")]),e._v("插件实现将这些框架作为一个个的"),n("code",[e._v("动态链接库")]),e._v("，只构建"),n("code",[e._v("一次")]),e._v("，以后的每次构建都"),n("code",[e._v("只会")]),e._v("生成自己的"),n("code",[e._v("业务代码")]),e._v("，可以很好的提高构建效率")]),e._v(" "),n("p",[e._v("主要思想在于，将一些"),n("code",[e._v("不做修改")]),e._v("的"),n("code",[e._v("依赖文件")]),e._v("，"),n("code",[e._v("提前打包")]),e._v("，这样我们开发代码发布的时候就"),n("code",[e._v("不需要再对")]),e._v("这些代码进行"),n("code",[e._v("打包")]),e._v("，从而节省了打包时间。")]),e._v(" "),n("p",[e._v("主要使用两个插件: "),n("code",[e._v("DLLPlugin")]),e._v("和"),n("code",[e._v("DLLReferencePlugin")])]),e._v(" "),n("blockquote",[n("p",[e._v("需要注意的是，若是使用DLLPlugin，CleanWebpackPlugin插件会存在冲突，需要移除CleanWebpackPlugin插件")])]),e._v(" "),n("p",[n("strong",[e._v("DLLPlugin：")])]),e._v(" "),n("p",[e._v("使用一个单独webpack配置创建一个"),n("code",[e._v("dll文件")]),e._v("，并且它还创建一个"),n("code",[e._v("manifest.json")]),e._v("，")]),e._v(" "),n("p",[e._v("DLLReferencePlugin使用"),n("code",[e._v("该json文件")]),e._v("来做"),n("code",[e._v("映射依赖性")]),e._v("，这个文件会告诉webpack哪些文件已经提前打包好了")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("配置参数")]),e._v(" "),n("ul",[n("li",[e._v("context(可选): manifest文件中请求的上下文，默认为该webpack文件上下文")]),e._v(" "),n("li",[e._v("name: 公开的dll函数的名称，和output.library保持一致即可")]),e._v(" "),n("li",[e._v("path: manifest.json 生成的文件夹及名称")])])])]),e._v(" "),n("p",[n("strong",[e._v("DLLReferencePlugin：")])]),e._v(" "),n("p",[e._v("该插件主要用于主webpack配置，它引用的dll需要预先构建的依赖该系")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("配置参数")]),e._v(" "),n("ul",[n("li",[e._v("context: manifest文件中的请求上下文")]),e._v(" "),n("li",[e._v("manifest: DLLPlugin插件生成的manifest.")]),e._v(" "),n("li",[e._v("jsoncontent(可选): 请求的映射模块id(默认为manifest.content)")]),e._v(" "),n("li",[e._v("name(可选): dll暴露的名称")]),e._v(" "),n("li",[e._v("scope(可选): 前缀用于访问dll的文件")]),e._v(" "),n("li",[e._v("sourceType(可选): dll是如何暴露(libraryTarget)")])])])]),e._v(" "),n("p",[n("strong",[e._v("将VUE项目中的库抽取成DLL:")])]),e._v(" "),n("ol",[n("li",[e._v("准备一份将VUE打包成DLL的"),n("code",[e._v("webpack配置文件")]),e._v("。")])]),e._v(" "),n("ul",[n("li",[e._v("在"),n("code",[e._v("build")]),e._v("目录下新建一个文件"),n("code",[e._v("webpack.vue.js")]),e._v("，专门用于打包vue的DLL的。")]),e._v(" "),n("li",[e._v("配置入口：将多个要做成dll的库全放进来")]),e._v(" "),n("li",[e._v("配置出口：一定要设置library属性，将打包好的结果暴露在全局")]),e._v(" "),n("li",[e._v("配置plugin：设置打包后dll文件名和manifest文件所在地")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 此配置文件 是打包VUE全家桶的\nconst path = require('path')\nconst webpack = require('webpack')\n\nmodule.exports = {\n  mode: 'production',\n  entry:{\n    vue: [ \n      'vue/dist/vue',\n      'vue-router'\n    ]\n  },\n  output:{\n    path: path.resolve(__dirname, '../dist'),\n    filename: '[name]_dll.js',\n    library: '[name]_dll' // 最终会在全局暴露出一个[name]_dll的对象\n  },\n  plugins:[\n    new webpack.DllPlugin({\n      name: '[name]_dll',\n      path: path.resolve(__dirname, '../dist/manifest.json'),\n    })\n  ]\n}\n")])])]),n("p",[e._v("webpack.vue.js 只是用来打包生成 [name]_dd.js 文件和 manifest.json文件的，是不需要参与到业务代码打包的，因为只会在每一次修改了需要生成dll文件的时间才会执行一次，否则不需要参与到打包")]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[e._v("在webpack.base.js中进行插件的配置")])]),e._v(" "),n("p",[e._v("使用DllReferencePlugin指定manifest文件的位置即可")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("new webpack.DllReferencePlugin({\n manifest: path.resolve(__dirname, '../dist/manifest.json'),\n})\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("由于[name]_dll文件生成之后，并没有动态的引入进去，所以需要一个插件可以动态的将生成的dll文件引入")])]),e._v(" "),n("p",[e._v("安装")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm i -D add-asset-html-webpack-plugin\n")])])]),n("p",[e._v("配置插件自动添加script标签到HTML中，需要注意的是，必须在HtmlWebpackPlugin后面引入，因为HtmlWebpackPlugin是生产一个html文件，AddAssetHtmlWebpackPlugin是在已有的html中注入一个script，否则会被覆盖")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("new AddAssetHtmlWebpackPlugin({\n  filepath: path.resolve(__dirname, '../dist/vue_dll.js')\n})\n")])])]),n("h2",{attrs:{id:"_10-ignore-plugin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-ignore-plugin"}},[e._v("#")]),e._v(" 10. Ignore   Plugin")]),e._v(" "),n("blockquote",[n("p",[e._v("在引入一些第三方模块时，例如momentJS、dayJS，其内部会做i18n处理，所以会包含很多语言包，而语言包打包时会比较占用空间，如果项目只需要用到中文或者少数语言，可以忽略掉所有的语言包，然后按需引入语言包，从而使得构建效率更高，打包生成的文件更小")])]),e._v(" "),n("p",[n("strong",[e._v("以moment为例")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import moment from 'moment'\nmoment.locale('zh-CN') // 设置为中文\n\nconsole.log(moment().subtract(6, 'days').calendar())\n")])])]),n("p",[e._v("首先要找到moment依赖的语言包时什么，通过查看moment的源码来分析")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function loadLocale(name) {\n    var oldLocale = null;\n    // TODO: Find a better way to register and load all the locales in Node\n    if (!locales[name] && (typeof module !== 'undefined') &&\n            module && module.exports) {\n        try {\n            oldLocale = globalLocale._abbr;\n            var aliasedRequire = require;\n            aliasedRequire('./locale/' + name);\n            getSetGlobalLocale(oldLocale);\n        } catch (e) {}\n    }\n    return locales[name];\n}\n")])])]),n("p",[e._v("通过 aliasedRequire('./locale/' + name) 可以知道momentJS的多语言目录是locale，所有的语言JS文件都在这个目录中")]),e._v(" "),n("p",[e._v("使用IgnorePlugin插件忽略其依赖")]),e._v(" "),n("p",[e._v("将momentJS的多语言目录locale忽略")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("new webpack.IgnorePlugin(/\\.\\/locale/, /moment/)\n")])])]),n("p",[e._v("需要使用某些依赖时自行手动引入")]),e._v(" "),n("p",[e._v("忽略其依赖之后，moment.locale('zh-CN')就会失效，因为其所依赖的语言包全都被忽略了，需要手动将其引入")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import moment from 'moment'\nimport  'moment/locale/zh-cn' // 需要手动引入方可生效\nmoment.locale('zh-CN')\n\nconsole.log(moment().subtract(6, 'days').calendar())\n")])])]),n("h2",{attrs:{id:"_11-js优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_11-js优化"}},[e._v("#")]),e._v(" 11. JS优化")]),e._v(" "),n("blockquote",[n("p",[n("code",[e._v("code splitting")]),e._v(" 是webpack打包时用到的重要的优化特性之一")])]),e._v(" "),n("p",[e._v("此特性能够把代码分离到不同的"),n("code",[e._v("bundle")]),e._v("中，然后可以"),n("code",[e._v("按需加载")]),e._v("或者"),n("code",[e._v("并行加载")]),e._v("这些文件，")]),e._v(" "),n("p",[n("code",[e._v("代码分离")]),e._v("可以用于获取"),n("code",[e._v("更小")]),e._v("的bundle，以及控制资源"),n("code",[e._v("加载优先级")]),e._v("，如果能够合理的使用能够极大影响加载时间")]),e._v(" "),n("p",[n("strong",[e._v("三种常见的代码分离方法")])]),e._v(" "),n("ul",[n("li",[e._v("入口起点：使用entry配置，手动的分离代码")]),e._v(" "),n("li",[e._v("放置重复：使用 SplitChunksPlugin 去重和分离 chunk")]),e._v(" "),n("li",[e._v("动态导入：通过模块的内联函数调用来分离代码")])])])}),[],!1,null,null,null);a.default=l.exports}}]);