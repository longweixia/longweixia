(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{220:function(e,t,a){"use strict";a.r(t);var v=a(6),n=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("背景，原理，使用场景-用途，如何使用，优缺点，怎么优化，横向对比竞品，扩展引申相同原理的技术，或者更进一步，有更好的解决方案。")])]),e._v(" "),a("blockquote",[a("p",[e._v("STAR 点出问题，多种解决方法，为什么选这种，结果，还有更好的方法吗")])]),e._v(" "),a("h2",{attrs:{id:"_1-什么是ast"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是ast"}},[e._v("#")]),e._v(" 1. 什么是AST")]),e._v(" "),a("p",[a("code",[e._v("抽象语法树")]),e._v("（abstract syntax code，AST）是"),a("code",[e._v("源代码")]),e._v("的抽象语法结构的"),a("code",[e._v("树状")]),e._v("表示，树上的每个"),a("code",[e._v("节点")]),e._v("都表示源代码中的一种"),a("code",[e._v("结构")]),e._v("。")]),e._v(" "),a("p",[e._v("为什么说是抽象的，因为它把js代码进行了结构化的转化，转化为一种数据结构。")]),e._v(" "),a("p",[e._v("这种数据结构其实就是一个大的"),a("code",[e._v("json")]),e._v("对象，json我们都熟悉，他就像一颗枝繁叶茂的树。有树根，有树干，有树枝，有树叶，无论多小多大，都是一棵完整的树。")]),e._v(" "),a("p",[e._v("简单理解,就是把我们写的"),a("code",[e._v("代码")]),e._v("按"),a("code",[e._v("照一定的")]),e._v("规则"),a("code",[e._v("转换成一种")]),e._v("树形结构`。")]),e._v(" "),a("h2",{attrs:{id:"_2-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-原理"}},[e._v("#")]),e._v(" 2. 原理")]),e._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"ast",href:"/ast1.png"}},[a("img",{attrs:{src:"/ast1.png",alt:"order"}})])]),e._v(" "),a("p",[e._v("JavaScript 代码的编译和执行过程\n从上图中我们可以看到,"),a("code",[e._v("JavaScript引擎")]),e._v("做的第一件事情就是把JavaScript代码"),a("code",[e._v("编译成抽象语法树")])]),e._v(" "),a("h2",{attrs:{id:"_3-ast的用途"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-ast的用途"}},[e._v("#")]),e._v(" 3. AST的用途")]),e._v(" "),a("p",[e._v("AST的作用不仅仅是用来在JavaScript引擎的编译上，我们在实际的开发过程中也是经常使用的:")]),e._v(" "),a("ul",[a("li",[e._v("比如我们常用的babel插件将 ES6转化成ES5")]),e._v(" "),a("li",[e._v("使用 UglifyJS来压缩代码 、css预处理器、开发WebPack插件")]),e._v(" "),a("li",[e._v("Vue-cli前端自动化工具等等，这些底层原理都是基于AST来实现的")])]),e._v(" "),a("p",[e._v("AST能力十分强大， 能够帮助开发者理解JavaScript这门语言的精髓。")]),e._v(" "),a("h2",{attrs:{id:"_4-ast使用3个流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-ast使用3个流程"}},[e._v("#")]),e._v(" 4. AST使用3个流程")]),e._v(" "),a("p",[e._v('我们都知道,在传统的编译语言的流程中,程序的一段源代码在执行之前会经历三个步骤,统称为"编译":')]),e._v(" "),a("p",[a("strong",[e._v("(1)分词/词法分析")])]),e._v(" "),a("p",[e._v("这个过程会将由字符组成的"),a("code",[e._v("字符串")]),e._v("分解成有意义的"),a("code",[e._v("代码块")]),e._v(",这些代码块统称为"),a("code",[e._v("词法单元(token)")]),e._v(".")]),e._v(" "),a("p",[e._v("举个例子: "),a("code",[e._v("let a = 1")]),e._v(", 这段程序通常会被分解成为下面这些词法单元:")]),e._v(" "),a("ul",[a("li",[e._v("let 、a、=、1、 ；")]),e._v(" "),a("li",[e._v("空格是否被当成词法单元，取决于空格在这门语言中的意义。")])]),e._v(" "),a("p",[a("strong",[e._v("(2)解析/语法分析")])]),e._v(" "),a("p",[e._v("这个过程是将"),a("code",[e._v("词法单元流")]),e._v("转换成一个由"),a("code",[e._v("元素嵌套")]),e._v("所组成的代表了程序语法结构的"),a("code",[e._v("树")]),e._v(',这个树被称为"抽象语法树"（abstract syntax code，AST）')]),e._v(" "),a("p",[a("strong",[e._v("(3)代码生成")])]),e._v(" "),a("p",[e._v("将AST转换成"),a("code",[e._v("可执行代码")]),e._v("的过程被称为代码生成.")]),e._v(" "),a("h2",{attrs:{id:"_5-ast的结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-ast的结构"}},[e._v("#")]),e._v(" 5. AST的结构")]),e._v(" "),a("p",[a("strong",[e._v("我们先来看一组简单的AST树状结构:")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const team = \'大转转FE\'\n经过转化,输出如下AST树状结构:\n\n{\n  "type": "Program", //程序\n  "start": 0,\n  "end": 18,\n  "body": [\n    {\n      "type": "VariableDeclaration", //变量声明\n      "start": 0,\n      "end": 18,\n      "declarations": [ // 声明\n        {\n          "type": "VariableDeclarator", //变量声明器\n          "start": 6,\n          "end": 18,\n          "id": {\n            "type": "Identifier", //标识符\n            "start": 6,\n            "end": 8,\n            "name": "team"\n          },\n          "init": {\n            "type": "Literal", //字面量\n            "start": 11,\n            "end": 18,\n            "value": "大转转FE",\n            "raw": "\'大转转FE\'"\n          }\n        }\n      ],\n      "kind": "const"\n    }\n  ],\n  "sourceType": "module"\n}\n')])])]),a("p",[e._v("我们可以看到，一个标准的AST结构可以理解为一个json对象，那我们就可以通过一些方法去解析和操作它，"),a("a",{attrs:{href:"https://esprima.org/demo/parse.html#",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里我们先提供一个在线检测工具,大家可以自行去体验:"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"_6-ast编译过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-ast编译过程"}},[e._v("#")]),e._v(" 6. AST编译过程")]),e._v(" "),a("p",[a("strong",[e._v("AST编译流程图:")])]),e._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"ast",href:"/ast2.png"}},[a("img",{attrs:{src:"/ast2.png",alt:"order"}})])]),e._v(" "),a("p",[e._v("我们可以看到,AST工具会源代码经过四个阶段的转换：")]),e._v(" "),a("p",[a("strong",[e._v("6-1. 词法分析scanner")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var company = 'zhuanzhuan'\n")])])]),a("p",[e._v("假如有以上代码，在词法分析阶段，会先对整个代码进行"),a("code",[e._v("扫描")]),e._v("，生成"),a("code",[e._v("tokens流")]),e._v("。")]),e._v(" "),a("p",[e._v("扫描过程如下：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("通过"),a("code",[e._v("条件判断语句")]),e._v("判断这个字符是 "),a("code",[e._v("字母")]),e._v("， "),a("code",[e._v('"/"')]),e._v(",  "),a("code",[e._v('"数字"')]),e._v(" , "),a("code",[e._v("空格")]),e._v(" , "),a("code",[e._v('"(" , ")"')]),e._v(" , "),a("code",[e._v('";"')]),e._v(" 等等。")])]),e._v(" "),a("li",[a("p",[e._v("如果是"),a("code",[e._v("字母")]),e._v("会继续"),a("code",[e._v("往下")]),e._v("看如果还是"),a("code",[e._v("字母")]),e._v("或者"),a("code",[e._v("数字")]),e._v("，会继续这一过程直到不是为止，这个时候发现找到的这个字符串是一个 "),a("code",[e._v('"var"')]),e._v("， 是一个"),a("code",[e._v("Keyword")]),e._v("，并且"),a("code",[e._v("下一个")]),e._v("字符是一个 "),a("code",[e._v('"空格"')]),e._v("， 就会生成"),a("code",[e._v('{ "type" : "Keyword" , "value" : "var" }')]),e._v("放入数组中。")])]),e._v(" "),a("li",[a("p",[e._v("它继续"),a("code",[e._v("向下")]),e._v("找发现了一个字母 'company'(因为找到的上一个值是 \"var\" 这个时候如果它发现"),a("code",[e._v("下一个")]),e._v("字符"),a("code",[e._v("不是字母")]),e._v("可能直接就会"),a("code",[e._v("报错")]),e._v("返回)并且后面是空格，生成"),a("code",[e._v('{ "type" : "Identifier" , "value" : "company" }')]),e._v("放到数组中。")])]),e._v(" "),a("li",[a("p",[e._v("发现了一个 "),a("code",[e._v('"="')]),e._v(", 生成了"),a("code",[e._v('{ "type" :  "Punctuator" , "value" : "=" }')]),e._v("放到了数组中。")])]),e._v(" "),a("li",[a("p",[e._v('发现了\'zhuanzhuan\',生成了{ "type" : "String" , "value" :  "zhuanzhuan" }放到了数组中。')])])]),e._v(" "),a("p",[a("strong",[e._v("解析如下：")])]),e._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"ast",href:"/ast3.png"}},[a("img",{attrs:{src:"/ast3.png",alt:"order"}})])]),e._v(" "),a("p",[a("strong",[e._v("6-2.parser生成AST树")])]),e._v(" "),a("p",[e._v("这里我们使用"),a("code",[e._v("esprima")]),e._v("去生成, 安装相关依赖 "),a("code",[e._v("npm i  esprima --save")])]),e._v(" "),a("p",[e._v("以如下代码为例:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const company = 'zhuanzhuan'\n")])])]),a("p",[e._v("要得到其对应的AST,我们对其进行如下操作:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const esprima = require('esprima');\nlet code = 'const company = \"zhuanzhuan\" ';\nconst ast = esprima.parseScript(code);\nconsole.log(ast);\n")])])]),a("p",[e._v("运行结果如下:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ node test.js\nScript {\n  type: 'Program',\n  body: [\n    VariableDeclaration {\n      type: 'VariableDeclaration',\n      declarations: [Array],\n      kind: 'const'\n    }\n  ],\n  sourceType: 'script'\n}\n")])])]),a("p",[e._v("这样我们就得到了一棵AST树")]),e._v(" "),a("p",[a("strong",[e._v("6-3.traverse对AST树遍历,进行增删改查")])]),e._v(" "),a("p",[e._v("这里我们使用"),a("code",[e._v("estraverse")]),e._v("去完成, 安装相关依赖  "),a("code",[e._v("npm i estraverse  --save")])]),e._v(" "),a("p",[e._v("还是上面的代码, 我们更改为 "),a("code",[e._v("const team =  '大转转FE'")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const esprima = require('esprima');\nconst estraverse = require('estraverse');\nlet code = 'const company = \"zhuanzhuan\" ';\nconst ast = esprima.parseScript(code);\nestraverse.traverse(ast, {\n     enter: function (node) {\n     node.name = 'team';\n        node.value = \"大转转FE\";\n    }\n});\nconsole.log(ast);\n")])])]),a("p",[e._v("运行结果如下:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ node test.js\nScript {\n  type: 'Program',\n  body: [\n    VariableDeclaration {\n      type: 'VariableDeclaration',\n      declarations: [Array], //声明\n      kind: 'const',\n      name: 'team',\n      value: '大转转FE'\n    }\n  ],\n  sourceType: 'script',\n  name: 'team',\n  value: '大转转FE'\n}\n")])])]),a("p",[e._v("这样一来,我们就完成了对AST的遍历更新。")]),e._v(" "),a("p",[a("strong",[e._v("6-4.generator将更新后的AST转化成代码")]),e._v("\n这里我们使用"),a("code",[e._v("escodegen")]),e._v("去生成, 安装相关依赖 "),a("code",[e._v("npm i escodegen  --save")])]),e._v(" "),a("p",[e._v("整体代码结构如下:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const esprima = require('esprima');\nconst estraverse = require('estraverse');\nconst escodegen = require('escodegen');\nlet code = 'const company = \"zhuanzhuan\" ';\nconst ast = esprima.parseScript(code);\nestraverse.traverse(ast, {\n    enter: function (node) {\n     node.name = 'team';\n        node.value = \"大转转FE\";\n    }\n});\nconst transformCode = escodegen.generate(ast);\nconsole.log(transformCode);\n")])])]),a("p",[e._v("会得到如下结果:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ node test.js\nconst team = '大转转FE';\n\n")])])]),a("p",[e._v("这样一来,我们就完成了对一段简单代码的AST编译过程。")]),e._v(" "),a("h2",{attrs:{id:"_7-babel原理浅析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-babel原理浅析"}},[e._v("#")]),e._v(" 7. babel原理浅析")]),e._v(" "),a("p",[e._v("Babel插件就是"),a("code",[e._v("作用于")]),e._v("抽象语法树。")]),e._v(" "),a("p",[a("strong",[e._v("Babel 的三个主要处理步骤分别是：")])]),e._v(" "),a("ul",[a("li",[e._v("解析（parse）")]),e._v(" "),a("li",[e._v("转换（transform）")]),e._v(" "),a("li",[e._v("生成（generate）。")])]),e._v(" "),a("p",[a("strong",[e._v("解析")])]),e._v(" "),a("p",[e._v("将"),a("code",[e._v("代码")]),e._v("解析成"),a("code",[e._v("抽象语法树（AST）")]),e._v("，每个js引擎（比如Chrome浏览器中的V8引擎）都有自己的"),a("code",[e._v("AST解析器")]),e._v("，而Babel是通过"),a("a",{attrs:{href:"https://github.com/babel/babylon",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babylon"),a("OutboundLink")],1),e._v("实现的。")]),e._v(" "),a("p",[e._v("解析过程有两个阶段：")]),e._v(" "),a("ul",[a("li",[e._v("词法分析和语法分析，词法分析阶段把"),a("code",[e._v("字符串形式")]),e._v("的代码转换为"),a("code",[e._v("令牌（tokens）流")]),e._v("，令牌类似于AST中节点；")]),e._v(" "),a("li",[e._v("法分析阶段则会把一个"),a("code",[e._v("令牌流")]),e._v("转换成 "),a("code",[e._v("AST")]),e._v("的形式，同时这个阶段会把令牌中的信息转换成AST的表述结构。")])]),e._v(" "),a("p",[a("strong",[e._v("转换")])]),e._v(" "),a("p",[e._v("转换步骤"),a("code",[e._v("接收AST")]),e._v(" 并对其进行"),a("code",[e._v("遍历")]),e._v("，在此过程中对"),a("code",[e._v("节点")]),e._v("进行"),a("code",[e._v("添加")]),e._v("、"),a("code",[e._v("更新")]),e._v("及"),a("code",[e._v("移除")]),e._v("等操作。Babel通过"),a("code",[e._v("babel-traverse")]),e._v("对其进行"),a("code",[e._v("深度优先遍历")]),e._v("，维护AST树的整体状态，并且可完成对其的替换，删除或者增加节点，这个方法的参数为原始AST和自定义的转换规则，返回结果为转换后的AST。")]),e._v(" "),a("p",[a("strong",[e._v("生成")])]),e._v(" "),a("p",[e._v("代码生成步骤把最终（经过一系列转换之后）的 "),a("code",[e._v("AST")]),e._v(" 转换成字符串形式的代码，同时还会创建源码映射（source maps）(http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/)。.")]),e._v(" "),a("p",[e._v("代码生成其实很简单："),a("code",[e._v("深度优先遍历")]),e._v("整个 "),a("code",[e._v("AST")]),e._v("，然后构建可以"),a("code",[e._v("表示转换后")]),e._v("代码的"),a("code",[e._v("字符串")]),e._v("。")]),e._v(" "),a("p",[e._v("Babel通过babel-generator再"),a("code",[e._v("转换成js代码")]),e._v("，过程就是深度优先遍历整个AST，然后构建出可以表示转换后代码的字符串。")]),e._v(" "),a("h2",{attrs:{id:"_8-vue中ast抽象语法树的运用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue中ast抽象语法树的运用"}},[e._v("#")]),e._v(" 8. vue中AST抽象语法树的运用;")]),e._v(" "),a("p",[e._v("vue中AST主要运用在模板编译过程.")]),e._v(" "),a("p",[e._v("我们先来看看vue模板编译的整体流程图：")]),e._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"ast",href:"/ast4.png"}},[a("img",{attrs:{src:"/ast4.png",alt:"order"}})])]),e._v(" "),a("p",[a("strong",[e._v("vue模板编译")])]),e._v(" "),a("p",[e._v("vue中的模板编译主要分为三个步骤:")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("解析器阶段: 将 "),a("code",[e._v("template")]),e._v(" 里面的代码解析成"),a("code",[e._v("AST抽象语法树")]),e._v(";")])]),e._v(" "),a("li",[a("p",[e._v("优化器阶段: 将"),a("code",[e._v("AST")]),e._v("抽象语法树"),a("code",[e._v("静态标签")]),e._v("打上"),a("code",[e._v("tag")]),e._v(",防止"),a("code",[e._v("重复渲染")]),e._v("(优化了diff算法);")])]),e._v(" "),a("li",[a("p",[e._v("代码生成器阶段: 优化后的AST抽象语法树通过"),a("code",[e._v("generate")]),e._v("函数生成"),a("code",[e._v("render函数字符串")]),e._v("；")])])]),e._v(" "),a("p",[a("strong",[e._v("我们来看看vue源码的整体实现过程:")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  //生成ast的过程                                                 \n  const ast = parse(template.trim(), options)\n  //优化ast的过程,给ast抽象语法树静态标签打上tag,防止重复渲染\n  if (options.optimize !== false) {\n    optimize(ast, options)\n  }\n  //通过generate函数生成render函数字符串\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n")])])]),a("p",[a("code",[e._v("解析器")]),e._v("要实现的功能就是将"),a("code",[e._v("模板")]),e._v("解析成"),a("code",[e._v("AST")]),e._v("，我们这里主要来分析一下代码解析阶段，这里主要运用的是"),a("code",[e._v("parse()")]),e._v("这个函数。")]),e._v(" "),a("p",[e._v("事实上,"),a("code",[e._v("解析器内部")]),e._v("也分为好"),a("code",[e._v("几个")]),e._v("解析器,比如"),a("code",[e._v("HTML解析器")]),e._v("、"),a("code",[e._v("文本解析器")]),e._v("以及"),a("code",[e._v("过滤解析器")]),e._v("，其中最主要的就是HTML解析器。")]),e._v(" "),a("p",[e._v("HTML解析器的作用就是解析HTML，它在解析HTML的过程中会不断触发各种"),a("code",[e._v("钩子函数")]),e._v("，我们来看看代码实现：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("parseHTML(template, { \n    //解析开始标签\n    start (tag, attrs, unary, start, end) {\n \n    },\n    //解析结束标签\n    end (tag, start, end) {\n \n    },\n    //解析文本\n    chars (text: string, start: number, end: number) {\n \n    },\n    //解析注释\n    comment (text: string, start, end){\n \n    }\n})\n")])])]),a("p",[e._v("举个例子:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<div>我们是大转转FE</div>\n")])])]),a("p",[e._v("当上面这个模板被HTML解析器解析时,所触发的钩子函数依次是: start、chars、end。")]),e._v(" "),a("p",[e._v("所以HTML解析器在实现上是一个函数，它有两个参数----"),a("code",[e._v("模板和选项")]),e._v("，我们的模板是"),a("code",[e._v("一小段一小段")]),e._v("去截取与解析的，所以需要不断"),a("code",[e._v("循环截取")]),e._v("，我们来看看vue内部实现原理：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function parseHTML (html, options) {\n while (html) {\n    //判断父元素为正常标签的元素的逻辑\n   if (!lastTag || !isPlainTextElement(lastTag)) {\n     //vue中要判断是 文本、注释、条件注释、DOCTYPE、结束、开始标签\n     //除了文本标签， 其他的都是以 < 开头, 所以区分处理\n     var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n         //注释的处理逻辑\n         if (comment.test(html)) {}\n         //条件注释的处理逻辑\n         if (conditionalComment.test(html)) {}\n         //doctype的处理逻辑\n         var doctypeMatch = html.match(doctype);\n                if (doctypeMatch) {}\n                //结束标签的处理逻辑\n                var endTagMatch = html.match(endTag);\n                if (endTagMatch) {}\n                //开始标签的处理逻辑\n                var startTagMatch = parseStartTag();\n                if (startTagMatch) {}\n        }\n        \n             var text = (void 0), rest = (void 0), next = (void 0);\n             //解析文本\n             if (textEnd >= 0) {}\n             // \"<\" 字符在当前 html 字符串中不存在\n             if (textEnd < 0) {\n                text = html\n                html = ''\n              }\n              // 如果存在 text 文本\n              // 调用 options.chars 回调，传入 text 文本\n             if (options.chars && text) {\n               // 字符相关回调\n               options.chars(text)\n             }\n   }else{\n    // 父元素为script、style、textarea的处理逻辑\n   }\n }\n}\n")])])]),a("p",[e._v("以上就是vue解析器生成AST语法树的主流程了，代码细节的地方还需要自己去解读源码，源码位置:\\vue\\packages\\weex-template-compiler\\build.js")]),e._v(" "),a("p",[a("strong",[e._v("结语：")]),e._v("\nAST抽象语法树的知识点作为JavaScript中(任何编程语言中都有ast这个概念,这里就不过多赘述)相对基础的，也是最不可忽略的知识，带给我们的启发是无限可能的；它就像一把螺丝刀，能够拆解javascript这台庞大的机器，让我们能够看到一些本质的东西，同时也能通过它批量构建任何javascript代码。")])])}),[],!1,null,null,null);t.default=n.exports}}]);