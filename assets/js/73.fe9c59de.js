(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{254:function(e,t,n){"use strict";n.r(t);var a=n(6),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"_1-背景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-背景"}},[e._v("#")]),e._v(" 1. 背景")]),e._v(" "),n("blockquote",[n("p",[e._v("为什么会有vue3出来，当然是vue2有一些另开发者能明显感知的问题存在。")])]),e._v(" "),n("ul",[n("li",[e._v("Vue 的现有 API 是通过「选项」组织代码的，但是在大部分情况下，通过逻辑考虑来组织代码更有意义。")]),e._v(" "),n("li",[e._v("缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制。")]),e._v(" "),n("li",[e._v("类型推断不够友好。")])]),e._v(" "),n("h2",{attrs:{id:"_2-生命周期的变化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-生命周期的变化"}},[e._v("#")]),e._v(" 2.生命周期的变化")]),e._v(" "),n("blockquote",[n("p",[e._v("整体来看其实变化不大，使用"),n("code",[e._v("setup")]),e._v("代替了之前的"),n("code",[e._v("beforeCreate和created")]),e._v("，其他生命周期名字有些变化，功能都是没有变化的")])]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Vue2.x")]),e._v(" "),n("th",[e._v("Vue3")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("beforeCreate")]),e._v(" "),n("td",[e._v("使用 setup()")])]),e._v(" "),n("tr",[n("td",[e._v("created")]),e._v(" "),n("td",[e._v("使用 setup()")])]),e._v(" "),n("tr",[n("td",[e._v("beforeMount")]),e._v(" "),n("td",[e._v("onBeforeMount")])]),e._v(" "),n("tr",[n("td",[e._v("mounted")]),e._v(" "),n("td",[e._v("onMounted")])]),e._v(" "),n("tr",[n("td",[e._v("beforeUpdate")]),e._v(" "),n("td",[e._v("onBeforeUpdate")])]),e._v(" "),n("tr",[n("td",[e._v("updated")]),e._v(" "),n("td",[e._v("onUpdated")])]),e._v(" "),n("tr",[n("td",[e._v("beforeDestroy")]),e._v(" "),n("td",[e._v("onBeforeUnmount")])]),e._v(" "),n("tr",[n("td",[e._v("destroyed")]),e._v(" "),n("td",[e._v("onUnmounted")])]),e._v(" "),n("tr",[n("td",[e._v("errorCaptured")]),e._v(" "),n("td",[e._v("onErrorCaptured")])])])]),e._v(" "),n("h2",{attrs:{id:"_3-使用proxy代替defineproperty"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用proxy代替defineproperty"}},[e._v("#")]),e._v(" 3.使用proxy代替defineProperty")]),e._v(" "),n("h3",{attrs:{id:"object-defineproperty-语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty-语法"}},[e._v("#")]),e._v(" Object.defineProperty()语法")]),e._v(" "),n("p",[e._v("重点：vue为什么对数组对象的深层监听无法实现，因为组件每次渲染都是将data里的数据通过defineProperty进行响应式或者双向绑定上，之前没有后加的属性是不会被绑定上，也就不会触发更新渲染")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Object.defineProperty( Obj, 'name', {\n    enumerable: true, //可枚举\n    configurable: true, //可配置\n    // writable:true, //跟可配置不能同时存在\n    // value:'name',  //可写死直\n    get: function () {\n        return def\n    },\n    set: function ( val ) {\n        def = val\n    }\n} )\n")])])]),n("h3",{attrs:{id:"proxy的语法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proxy的语法"}},[e._v("#")]),e._v(" Proxy的语法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//两个参数，对象，13个配置项\nconst handler = {\n    get: function(obj, prop) {\n        return prop in obj ? obj[prop] : 37;\n    },\n    set:function(){ },\n    ...13个配置项\n};\nconst p = new Proxy({}, handler);\np.a = 1;\np.b = undefined;\nconsole.log(p.a, p.b);      // 1, undefined\nconsole.log('c' in p, p.c); // false, 37\n")])])]),n("p",[e._v("对比了上面两种语法是不是就懂了，defineProperty只能响应首次渲染时候的属性，Proxy需要的是整体(如上面例子的p)，不需要关心里面有什么属性，而且Proxy的配置项有13种，可以做更细致的事情，这是之前的defineProperty无法达到的")]),e._v(" "),n("h2",{attrs:{id:"_4-diff算法的提升"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-diff算法的提升"}},[e._v("#")]),e._v(" 4.Diff算法的提升")]),e._v(" "),n("h3",{attrs:{id:"以往的渲染策略"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#以往的渲染策略"}},[e._v("#")]),e._v(" 以往的渲染策略")]),e._v(" "),n("p",[e._v("vue2.x提供类似于HTML的模板语法，但是，它是将模板编译成渲染函数来返回虚拟DOM树。Vue框架通过递归遍历两个虚拟DOM树，并比较每个节点上的每个属性，来确定实际DOM的哪些部分需要更新。")]),e._v(" "),n("h3",{attrs:{id:"潜在的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#潜在的问题"}},[e._v("#")]),e._v(" 潜在的问题")]),e._v(" "),n("p",[e._v("由于现代JavaScript引擎执行的高级优化，这种有点暴力的算法通常非常快速，但是DOM的更新仍然涉及许多不必要的CPU工作，那么如何解决呢？")]),e._v(" "),n("h3",{attrs:{id:"vue3的突破"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue3的突破"}},[e._v("#")]),e._v(" Vue3的突破")]),e._v(" "),n("p",[e._v("引用尤雨溪：\n为了实现这一点，编译器和运行时需要协同工作：编译器分析模板并生成带有优化提示的代码，而运行时尽可能获取提示并采用快速路径。")]),e._v(" "),n("p",[n("strong",[e._v("这里有三个主要的优化")]),e._v("：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("首先，在"),n("code",[e._v("DOM树级别")]),e._v("。我们注意到，在没有动态改变节点结构的模板指令（例如v-if和v-for）的情况下，节点结构保持完全静态。如果我们将一个模板分成由这些结构指令分隔的嵌套“块”，则每个块中的节点结构将再次完全静态。当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟DOM的大部分开销。")])]),e._v(" "),n("li",[n("p",[e._v("其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。")])]),e._v(" "),n("li",[n("p",[e._v("第三，在元素级别。编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。")])])]),e._v(" "),n("p",[e._v("综合起来，这些技术大大改进了我们的渲染更新基准，Vue 3有时占用的CPU时间不到Vue 2的十分之一。")]),e._v(" "),n("h2",{attrs:{id:"_5-typescript的支持"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-typescript的支持"}},[e._v("#")]),e._v(" 5.typeScript的支持")]),e._v(" "),n("h3",{attrs:{id:"vue2-存在的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue2-存在的问题"}},[e._v("#")]),e._v(" vue2 存在的问题")]),e._v(" "),n("p",[e._v("vue2.x中使用的都是js，它本身并没有类型系统这个概念，对于规模很大的项目，没有类型声明，后期维护和代码的阅读都很困难，所以迫切的需要vue能完美支持ts。")]),e._v(" "),n("p",[n("strong",[e._v("Tips")]),e._v("： vue2是支持类型的，用的是"),n("code",[e._v("Facebook")]),e._v("的"),n("code",[e._v("Flow")]),e._v("做类型检查，但是因为某些情况下推断有问题。所以引入ts，一个是为了更好的做类型检查，另一个是拥抱ts")]),e._v(" "),n("h3",{attrs:{id:"如何实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何实现"}},[e._v("#")]),e._v(" 如何实现")]),e._v(" "),n("p",[e._v("最终vue3 借鉴了"),n("code",[e._v("react hook")]),e._v("实现了更自由的编程方式，提出了"),n("code",[e._v("Composition API")]),e._v("，Composition API不需要通过指定一长串选项来定义组件，而是允许用户像编写函数一样自由地表达、组合和重用有状态的组件逻辑，同时提供出色的TypeScript支持。")]),e._v(" "),n("h2",{attrs:{id:"_6-打包体积变化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-打包体积变化"}},[e._v("#")]),e._v(" 6.打包体积变化")]),e._v(" "),n("h3",{attrs:{id:"以前打包存在的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#以前打包存在的问题"}},[e._v("#")]),e._v(" 以前打包存在的问题")]),e._v(" "),n("p",[e._v("vue2官方说的运行时打包是23k，但这只是没安装依赖的时候，随着依赖包和框架特性的增多，有时候不必要的，未使用的代码文件都被打包了进去，所以后期项目大了，打包文件会特别多还很大。")]),e._v(" "),n("h3",{attrs:{id:"vue3是怎么做的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue3是怎么做的"}},[e._v("#")]),e._v(" vue3是怎么做的")]),e._v(" "),n("p",[e._v("在Vue 3中，我们通过将大多数全局API和内部帮助程序移动到Javascript的module.exports属性上实现这一点。这允许现代模式下的module bundler能够静态地分析模块依赖关系，并删除与未使用的module.exports属性相关的代码。模板编译器还生成了对树抖动友好的代码，只有在模板中实际使用某个特性时，该代码才导入该特性的帮助程序。\n尽管增加了许多新特性，但Vue 3被压缩后的基线大小约为10 KB，不到Vue 2的一半。")]),e._v(" "),n("h2",{attrs:{id:"_6-开始使用vue3-0"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-开始使用vue3-0"}},[e._v("#")]),e._v(" 6. 开始使用vue3.0")]),e._v(" "),n("p",[e._v("vue3完全兼容vue2，在vue3中依然可以按照vue2的方式去写代码，而且两种写法可以同时存在。\n所以目前项目使用Vue2的小伙伴们不用担心存在兼容性问题。")]),e._v(" "),n("ul",[n("li",[e._v("1.全新项目可以通过vite脚手架来安装。")]),e._v(" "),n("li",[e._v("2.老项目可以直接升级版本")])]),e._v(" "),n("p",[e._v("以下基于vite脚手架安装的方式展开：")]),e._v(" "),n("h3",{attrs:{id:"安装依赖-创建项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装依赖-创建项目"}},[e._v("#")]),e._v(" 安装依赖，创建项目")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//hello-vue3 为要创建的项目名字\nnpm init vite-app hello-vue3\n")])])]),n("p",[n("strong",[e._v("然后进入项目")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("cd hello-vue3\n")])])]),n("p",[n("strong",[e._v("安装依赖")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm install\n")])])]),n("p",[n("strong",[e._v("运行项目")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm run dev\n")])])]),n("p",[e._v("可以明显的感知，vite编译的速度非常快。")]),e._v(" "),n("h2",{attrs:{id:"_7-代码解释"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-代码解释"}},[e._v("#")]),e._v(" 7. 代码解释")]),e._v(" "),n("h3",{attrs:{id:"将vue3的helloworld-vue文件做些改动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将vue3的helloworld-vue文件做些改动"}},[e._v("#")]),e._v(" 将vue3的HelloWorld.vue文件做些改动")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//dom 里的东西基本上都是没有变的\n<template>\n  <h1>{{ msg }}</h1>\n  <button @click="increment">\n    count: {{ state.count }}, double: {{ state.double }},three：{{ three }},refnum：{{refnum}}\n  </button>\n</template>\n\n<script>\n//这里就是Vue3的组合Api了，这里跟react的 import { useState ,useEffect } from \'react\' 有些类似，需要用啥引啥\nimport {ref, reactive, computed ,watchEffect,watch} from "vue";\nexport default {\n  name: "HelloWorld",\n  props: {\n    msg: String,\n  },\n  //上面对比的时候说过，setup相当于beforeCreate 和created，简单理解就是初始化\n  setup() { \n  \t//这里通过reactive使state成为相应状态（后面会详细介绍）\n    const state = reactive({\n      count: 0,\n      //计算属性computed的使用更灵活了\n      double: computed(() => state.count * 2),\n    });\n    //computed也可以单独拿出来使用\n    const three = computed(() => state.count * 3)\n    //ref跟reactive作用一样都是用来双向绑定的，ref的颗粒度更小（后面详细对比）\n\tconst refnum = ref()\n   //这里的watchEffect只要里面的变量发生了改变就会执行,并且第一次渲染会立即执行,没有变化前后返回参数，无法监听整个reactive\n    watchEffect(() => {\n      refnum.value = state.count;\n      console.log(state, "watchEffect");\n    });\n    //watch里第一个参数是监听需要的变量，第二个是执行的回调函数，\n    watch(refnum,(a,b)=>{\n      console.log(a,b,\'watch,a,b\')\n    })\n    //所有的方法里再也不需要用this了，这是很爽的\n    function increment() {\n      state.count++;\n    }\n   \t//组中模板中需要的变量，都要通过return给暴露出去，就像当初data({return { } }) 是一样的\n    return {\n      state,\n      increment,\n      three,\n      refnum\n    };\n  },\n};\n<\/script>\n')])])]),n("h3",{attrs:{id:"生命周期的使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#生命周期的使用"}},[e._v("#")]),e._v(" 生命周期的使用")]),e._v(" "),n("p",[e._v("上面对比的时候也说了，生命周期命名改变了更有语义化了，使用方法也改变（这里有点像react 的useEffect(()=>{ })），使用前需要我们在组合Api里获取。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<script>\nimport {\n  reactive,\n  computed,\n  onMounted,\n  onBeforeMount,\n  onBeforeUpdate,\n  onUpdated,\n  onUnmounted,\n  onBeforeUnmount,\n} from "vue";\n\nexport default {\n  setup() {\n    const state = reactive({\n      count: 0,\n      double: computed(() => state.count * 2),\n    });\n    function increment() {\n      state.count++;\n    }\n    onUpdated(() => {\n      console.log("onUpdated");\n    });\n    onUnmounted(() => {\n      console.log("onUnmounted");\n    });\n    onBeforeUnmount(() => {\n      console.log("onBeforeUnmount");\n    });\n    onBeforeUpdate(() => {\n      console.log("onBeforeUpdate1");\n    });\n    onMounted(() => {\n      console.log("onMounted");\n    });\n    onBeforeMount(() => {\n      console.log("onBeforeMount");\n    });\n    console.log("setup");\n    return {\n      state,\n      increment,\n    };\n  },\n};\n<\/script>\n')])])]),n("p",[e._v("//生命周期的执行顺序还是和以前一样的。")]),e._v(" "),n("h2",{attrs:{id:"_8-组件api的使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-组件api的使用"}},[e._v("#")]),e._v(" 8. 组件Api的使用")]),e._v(" "),n("h3",{attrs:{id:"setup"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#setup"}},[e._v("#")]),e._v(" setup")]),e._v(" "),n("p",[e._v("setup替代了以前的 beforeCreate 和 created ，类似于初始化的功能")]),e._v(" "),n("p",[e._v("父组件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n  <img alt="Vue logo" src="./assets/logo.png" />\n  <HelloWorld msg="Baby张  Vue3 RC" />\n  //这里传参给子组件\n</template>\n<script>\nimport HelloWorld from "./components/HelloWorld.vue";\nimport { provide } from "vue";\nexport default {\n  name: "App",\n  components: {\n    HelloWorld,\n  }\n};\n<\/script>\n')])])]),n("p",[e._v("子组件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <h1>{{msg}}</h1>\n</template>\n\n<script>\n export default {\n    name: 'HelloWorld',\n    props:[\"msg\"],\n\tsetup(props, ctx) {\n        //props 接收的父组件传的参数，这就有点像react的props了\n        //ctx 这个参数表示的当前对象实例，也就个是变相的this\n\t\tconsole.log('拿到值==', props.msg, ctx)\n    },\n      \n}\n<\/script>\n")])])]),n("p",[e._v("如果你还想要更多当前组件相关的属性，还可以从组合Api 里引用 getCurrentInstance")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' import {getCurrentInstance } from "vue";\n const  all  = getCurrentInstance()\n console.log(all, "app-setup");\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);