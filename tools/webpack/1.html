<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>资料库</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <link rel="icon" href="/longweixia/favicon.ico">
    <meta name="description" content="10点读书">
    
    <link rel="preload" href="/longweixia/assets/css/0.styles.e7f35309.css" as="style"><link rel="preload" href="/longweixia/assets/js/app.30853e2a.js" as="script"><link rel="preload" href="/longweixia/assets/js/2.19b4ab8a.js" as="script"><link rel="preload" href="/longweixia/assets/js/53.c938b0b0.js" as="script"><link rel="prefetch" href="/longweixia/assets/js/10.17389278.js"><link rel="prefetch" href="/longweixia/assets/js/11.13e843aa.js"><link rel="prefetch" href="/longweixia/assets/js/12.9ad5d840.js"><link rel="prefetch" href="/longweixia/assets/js/13.79fcf880.js"><link rel="prefetch" href="/longweixia/assets/js/14.c4361c82.js"><link rel="prefetch" href="/longweixia/assets/js/15.44426049.js"><link rel="prefetch" href="/longweixia/assets/js/16.581eff27.js"><link rel="prefetch" href="/longweixia/assets/js/17.d109ff42.js"><link rel="prefetch" href="/longweixia/assets/js/18.3ec7fcf3.js"><link rel="prefetch" href="/longweixia/assets/js/19.35fd21bb.js"><link rel="prefetch" href="/longweixia/assets/js/20.66a6e34b.js"><link rel="prefetch" href="/longweixia/assets/js/21.71051137.js"><link rel="prefetch" href="/longweixia/assets/js/22.9869167b.js"><link rel="prefetch" href="/longweixia/assets/js/23.2ca1aaba.js"><link rel="prefetch" href="/longweixia/assets/js/24.2232ffb7.js"><link rel="prefetch" href="/longweixia/assets/js/25.e0f0715a.js"><link rel="prefetch" href="/longweixia/assets/js/26.f5c106a0.js"><link rel="prefetch" href="/longweixia/assets/js/27.9e31faa4.js"><link rel="prefetch" href="/longweixia/assets/js/28.113fc19e.js"><link rel="prefetch" href="/longweixia/assets/js/29.bc167a67.js"><link rel="prefetch" href="/longweixia/assets/js/3.88b3d293.js"><link rel="prefetch" href="/longweixia/assets/js/30.03a76239.js"><link rel="prefetch" href="/longweixia/assets/js/31.c81c40f1.js"><link rel="prefetch" href="/longweixia/assets/js/32.bd90225a.js"><link rel="prefetch" href="/longweixia/assets/js/33.1d2874e8.js"><link rel="prefetch" href="/longweixia/assets/js/34.b5be839b.js"><link rel="prefetch" href="/longweixia/assets/js/35.346f3036.js"><link rel="prefetch" href="/longweixia/assets/js/36.81c5024f.js"><link rel="prefetch" href="/longweixia/assets/js/37.c67ed549.js"><link rel="prefetch" href="/longweixia/assets/js/38.77987057.js"><link rel="prefetch" href="/longweixia/assets/js/39.9c901ab8.js"><link rel="prefetch" href="/longweixia/assets/js/4.793f9f6e.js"><link rel="prefetch" href="/longweixia/assets/js/40.3bf5737a.js"><link rel="prefetch" href="/longweixia/assets/js/41.10d00b34.js"><link rel="prefetch" href="/longweixia/assets/js/42.d1c1060a.js"><link rel="prefetch" href="/longweixia/assets/js/43.f8e83df1.js"><link rel="prefetch" href="/longweixia/assets/js/44.0da5d0cd.js"><link rel="prefetch" href="/longweixia/assets/js/45.94d21e4f.js"><link rel="prefetch" href="/longweixia/assets/js/46.9d1beff0.js"><link rel="prefetch" href="/longweixia/assets/js/47.adbb41c5.js"><link rel="prefetch" href="/longweixia/assets/js/48.905e25b7.js"><link rel="prefetch" href="/longweixia/assets/js/49.2763efa3.js"><link rel="prefetch" href="/longweixia/assets/js/5.e7ca5135.js"><link rel="prefetch" href="/longweixia/assets/js/50.ffe0192f.js"><link rel="prefetch" href="/longweixia/assets/js/51.b4a8bbd5.js"><link rel="prefetch" href="/longweixia/assets/js/52.3bf3d83c.js"><link rel="prefetch" href="/longweixia/assets/js/54.a12149e7.js"><link rel="prefetch" href="/longweixia/assets/js/55.2f8f4d12.js"><link rel="prefetch" href="/longweixia/assets/js/56.b040f922.js"><link rel="prefetch" href="/longweixia/assets/js/57.3565cde1.js"><link rel="prefetch" href="/longweixia/assets/js/58.ddccb3ba.js"><link rel="prefetch" href="/longweixia/assets/js/59.052024c3.js"><link rel="prefetch" href="/longweixia/assets/js/6.a797012b.js"><link rel="prefetch" href="/longweixia/assets/js/60.6ef28404.js"><link rel="prefetch" href="/longweixia/assets/js/61.512be1bf.js"><link rel="prefetch" href="/longweixia/assets/js/62.6e05c141.js"><link rel="prefetch" href="/longweixia/assets/js/63.ca304a0d.js"><link rel="prefetch" href="/longweixia/assets/js/64.6477c58d.js"><link rel="prefetch" href="/longweixia/assets/js/65.e0da78df.js"><link rel="prefetch" href="/longweixia/assets/js/66.e109c264.js"><link rel="prefetch" href="/longweixia/assets/js/67.e498d6df.js"><link rel="prefetch" href="/longweixia/assets/js/68.276ed907.js"><link rel="prefetch" href="/longweixia/assets/js/69.2bc6a533.js"><link rel="prefetch" href="/longweixia/assets/js/7.55c60d55.js"><link rel="prefetch" href="/longweixia/assets/js/70.bb6787af.js"><link rel="prefetch" href="/longweixia/assets/js/71.5ac32627.js"><link rel="prefetch" href="/longweixia/assets/js/72.ba9cb06b.js"><link rel="prefetch" href="/longweixia/assets/js/73.fe9c59de.js"><link rel="prefetch" href="/longweixia/assets/js/74.ecb3f57f.js"><link rel="prefetch" href="/longweixia/assets/js/75.0169e10d.js"><link rel="prefetch" href="/longweixia/assets/js/76.f804ad10.js"><link rel="prefetch" href="/longweixia/assets/js/77.49c57594.js"><link rel="prefetch" href="/longweixia/assets/js/78.a2f5ab6e.js"><link rel="prefetch" href="/longweixia/assets/js/79.acb9ebc0.js"><link rel="prefetch" href="/longweixia/assets/js/8.cce1d689.js"><link rel="prefetch" href="/longweixia/assets/js/80.8d936fe0.js"><link rel="prefetch" href="/longweixia/assets/js/81.0e3986b9.js"><link rel="prefetch" href="/longweixia/assets/js/82.774d6e22.js"><link rel="prefetch" href="/longweixia/assets/js/83.c0ddf8bb.js"><link rel="prefetch" href="/longweixia/assets/js/84.5a58253a.js"><link rel="prefetch" href="/longweixia/assets/js/85.20ba04b9.js"><link rel="prefetch" href="/longweixia/assets/js/9.023f9158.js">
    <link rel="stylesheet" href="/longweixia/assets/css/0.styles.e7f35309.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/longweixia/" class="home-link router-link-active"><!----> <span class="site-name">资料库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/longweixia/html/" class="nav-link">
  HTML
</a></div><div class="nav-item"><a href="/longweixia/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/longweixia/js/" class="nav-link">
  JS
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/longweixia/html/" class="nav-link">
  HTML
</a></div><div class="nav-item"><a href="/longweixia/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/longweixia/js/" class="nav-link">
  JS
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/html/" class="sidebar-heading clickable"><span>1. HTML</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/css/" class="sidebar-heading clickable"><span>2. CSS</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/js/" class="sidebar-heading clickable"><span>3. JS</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/vue/" class="sidebar-heading clickable"><span>4. Vue</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/ts/" class="sidebar-heading clickable"><span>5. TS</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/node/" class="sidebar-heading clickable"><span>6. Node</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/business/" class="sidebar-heading clickable"><span>7. 业务</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/tools/" class="sidebar-heading clickable router-link-active open"><span>8. 工具</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>vscode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>webpack</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/longweixia/tools/webpack/1.html" aria-current="page" class="active sidebar-link">webpack 提高构建速度的方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_1-缩小文件的搜索范围" class="sidebar-link">1 缩小文件的搜索范围</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_1-1优化loader配置" class="sidebar-link">1-1优化Loader配置</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_1-2-优化loader配置优化resolve-modules配置-resolve项" class="sidebar-link">1-2.优化Loader配置优化resolve.modules配置（resolve项）</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_1-3-优化resolve-alias配置-resolve项" class="sidebar-link">1-3.优化resolve.alias配置（resolve项）</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_1-4-优化resolve-extensions配置" class="sidebar-link">1-4. 优化resolve.extensions配置</a></li></ul></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_2-减少冗余代码" class="sidebar-link">2. 减少冗余代码</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_3-使用happypack多进程解析和处理文件" class="sidebar-link">3. 使用HappyPack多进程解析和处理文件</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_4-使用paralleluglifyplugin多进程压缩代码文件" class="sidebar-link">4. 使用ParallelUglifyPlugin多进程压缩代码文件</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_5-使用自动刷新" class="sidebar-link">5. 使用自动刷新</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_6-开启模块热替换" class="sidebar-link">6. 开启模块热替换</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_7-提取公共代码" class="sidebar-link">7. 提取公共代码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_8-通过webpack-bundle-analyzer分析代码包的大小" class="sidebar-link">8. 通过webpack-bundle-analyzer分析代码包的大小</a></li></ul></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_9-dll-plugin" class="sidebar-link">9. DLL  Plugin</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_10-ignore-plugin" class="sidebar-link">10. Ignore   Plugin</a></li><li class="sidebar-sub-header"><a href="/longweixia/tools/webpack/1.html#_11-js优化" class="sidebar-link">11. JS优化</a></li></ul></li><li><a href="/longweixia/tools/webpack/2.html" class="sidebar-link">什么是loader</a></li><li><a href="/longweixia/tools/webpack/3.html" class="sidebar-link">webpack原理</a></li><li><a href="/longweixia/tools/webpack/4.html" class="sidebar-link">webpack 动态加载的原理</a></li><li><a href="/longweixia/tools/webpack/5.html" class="sidebar-link">webpack 热更新</a></li><li><a href="/longweixia/tools/webpack/6.html" class="sidebar-link">如何写一个 webpack plugin 热更新</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/browser/" class="sidebar-heading clickable"><span>9. 浏览器</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/vuePress/" class="sidebar-heading clickable"><span>10. vuePress</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/xcx/" class="sidebar-heading clickable"><span>11. 小程序</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/longweixia/note/" class="sidebar-heading clickable"><span>12. 总结</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>原理，使用，优缺点，怎么优化，横向对比竞品，扩展引申相同原理的技术，或者更进一步，有更好的解决方案。</p></blockquote> <blockquote><p>STAR 背景，点出问题，多种解决方法，为什么选这种，结果，还有更好的方法吗</p></blockquote> <h2 id="_1-缩小文件的搜索范围"><a href="#_1-缩小文件的搜索范围" class="header-anchor">#</a> 1 缩小文件的搜索范围</h2> <h3 id="_1-1优化loader配置"><a href="#_1-1优化loader配置" class="header-anchor">#</a> 1-1优化Loader配置</h3> <blockquote><p>loader相关的知识，请查看文章：<strong>什么webpack的loader</strong></p></blockquote> <p>由于Loader对文件的转换操作很耗时，所以需要让尽可能少的文件被Loader处理。<br>
我们可以通过以下3方面优化Loader配置：</p> <ul><li>（1）优化正则匹配</li> <li>（2）通过cacheDirectory选项开启缓存</li> <li>（3）通过include、exclude来减少被处理的文件。</li></ul> <p><strong>实践如下：</strong></p> <p>项目原配置：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  test: /\.js$/,
  loader: 'babel-loader',
  include: [resolve('src'), resolve('test')]
},
</code></pre></div><p>优化后配置：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  // 1、如果项目源码中只有js文件，就不要写成/\.jsx?$/，以提升正则表达式的性能
  test: /\.js$/,
  // 2、babel-loader支持缓存转换出的结果，通过cacheDirectory选项开启
  loader: 'babel-loader?cacheDirectory',
  // 3、只对项目根目录下的src 目录中的文件采用 babel-loader
  include: [resolve('src')]
},
</code></pre></div><h3 id="_1-2-优化loader配置优化resolve-modules配置-resolve项"><a href="#_1-2-优化loader配置优化resolve-modules配置-resolve项" class="header-anchor">#</a> 1-2.优化Loader配置优化resolve.modules配置（resolve项）</h3> <p><code>resolve.modules</code> 用于配置Webpack去哪些<code>目录</code>下寻找<code>第三方模块</code>。</p> <p>resolve.modules的默认值是<code>［node modules］</code>，含义是<code>先去当前目录</code>的<code>/node modules</code>目录下去找我们想找的<code>模块</code>，如果没找到，就去<code>上一级</code>目录<code>../node modules</code>中找，再没有就去<code>../ .. /node modules</code>中找，以此类推</p> <p>这和Node.js的模块寻找机制很相似。当安装的<code>第三方模块</code>都放在项目<code>根目录的./node modules</code>目录下时，就没有必要按照默认的方式去一层层地寻找，可以指明存放<code>第三方模块的绝对路径</code>，以减少寻找。</p> <p><strong>优化后配置：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>resolve: {
// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
modules: [path.resolve(__dirname,'node_modules')]
},
</code></pre></div><h3 id="_1-3-优化resolve-alias配置-resolve项"><a href="#_1-3-优化resolve-alias配置-resolve项" class="header-anchor">#</a> 1-3.优化resolve.alias配置（resolve项）</h3> <p><code>resolve.alias</code>配置项通过<code>别名</code>来将<code>原导入路径</code>映射成一个<code>新的导入路径</code>。</p> <p><strong>如项目中的配置使用：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>alias: {
  '@': resolve('src'),
},
// 通过以上的配置，引用src底下的common.js文件，就可以直接这么写
import common from '@/common.js';//相当于 import common from 'src/common.js'
</code></pre></div><h3 id="_1-4-优化resolve-extensions配置"><a href="#_1-4-优化resolve-extensions配置" class="header-anchor">#</a> 1-4. 优化resolve.extensions配置</h3> <p>在导入语句<code>没带文件后缀</code>时，Webpack 会在<code>自动带上后缀</code>后去<code>尝试询问文件是否存在</code>。默认是：<code>extensions :['. js ','. json ']</code> 。</p> <ul><li>也就是说，当遇到<code>require ( '. /data '）</code>这样的导入语句时，Webpack会先去寻找<code>./data .js</code>文件</li> <li>如果该文件不存在，就去寻找<code>./data.json</code> 文件，如果还是找不到就报错。</li> <li>如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以 resolve .extensions 的配置也会影响到<code>构建的性能</code>。</li></ul> <p><strong>优化措施：</strong></p> <ul><li><code>后缀尝试列表</code>要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中。</li> <li>频率出现<code>最高</code>的文件后缀要<code>优先放在最前面</code>，以做到尽快退出寻找过程。</li> <li>在源码中写<code>导入语句</code>时，要尽可能<code>带上后缀</code>，从而可以避免寻找过程。例如在确定的情况下将 <code>require('. /data ')</code>写成<code>require(' /data.json')</code>，可以结合enforceExtension 和 enforceModuleExtension开启使用来强制开发者遵守这条优化</li></ul> <h4 id="_1-5-优化resolve-noparse配置"><a href="#_1-5-优化resolve-noparse配置" class="header-anchor">#</a> 1-5. 优化resolve.noParse配置</h4> <p><code>noParse</code>配置项可以让<code>Webpack忽略</code>对部分<code>没采用模块化</code>的文件的<code>递归解析和处理</code>，这 样做的好处是能提高构建性能。</p> <p>原因是一些库如<code>jQuery、ChartJS</code>庞大又<code>没有采用模块化标准</code>，让Webpack去<code>解析</code>这些文件既<code>耗时又没有意义</code>。</p> <p>noParse是可选的配置项，类型需要是<code>RegExp 、[RegExp]、function</code>中的一种。</p> <p><strong>例如，若想要忽略jQuery 、ChartJS ，则优化配置如下：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>// 1. 使用正则表达式 
noParse: /jquerylchartjs/ 
// 2. 使用函数，从 Webpack3.0.0开始支持 
noParse: (content)=&gt; { 
// 返回true或false 
return /jquery|chartjs/.test(content); 
}
</code></pre></div><h2 id="_2-减少冗余代码"><a href="#_2-减少冗余代码" class="header-anchor">#</a> 2. 减少冗余代码</h2> <p><code>babel-plugin-transform-runtime</code> 是<code>Babel</code>官方提供的一个<code>插件</code>，作用是减少冗余的代码 。</p> <p>Babel在将<code>ES6代码转换</code>成<code>ES5代码</code>时，通常需要一些由<code>ES5编写</code>的<code>辅助函数</code>来完成新语法的实现。</p> <p>例如在转换ES6的 <code>class</code> 语法时会在<code>转换后</code>的 <code>ES5</code> 代码里注入 extent 辅助函数用于实现继承。</p> <p>并且babel 默认会将这些辅助函数<code>内联</code>到<code>每一个 js 文件</code>里，这样文件多的时候，项目就会很大。</p> <p>所以 babel 提供了 babel-plugin-transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，然后通过导入语句引用进来，从而减小babel编译出来的代码的文件大小。</p> <h2 id="_3-使用happypack多进程解析和处理文件"><a href="#_3-使用happypack多进程解析和处理文件" class="header-anchor">#</a> 3. 使用HappyPack多进程解析和处理文件</h2> <p>由于有<code>大量文件</code>需要<code>解析和处理</code>，所以<code>构建</code>是<code>文件读写</code>和<code>计算密集型</code>的操作，特别是当文件数量变多后，Webpack构建慢的问题会显得更为严重。
运行在 Node.之上的Webpack是<code>单线程模型</code>的（webpack的运行依赖于node的环境，没有node是不能打包的，所以Webpack也是单线程的），也就是说Webpack需要一个一个地处理任务，不能同时处理多个任务。</p> <p><a href="https://github.com/amireh/happypack" target="_blank" rel="noopener noreferrer">Happy Pack<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就能让Webpack做到这一点，它将<code>任务分解</code>给<code>多个子进程</code>去<code>并发执行</code>，子进程<code>处理完</code>后再将<code>结果发送给主进程</code>。</p> <p><strong>项目中HappyPack使用配置：</strong></p> <ol><li><p>HappyPack插件安装：</p> <div class="language- extra-class"><pre class="language-text"><code>$ npm i -D happypack
</code></pre></div></li> <li><p>webpack.base.conf.js 文件对module.rules进行配置</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>    module: {
     rules: [
      {
        test: /\.js$/,
        // 将对.js 文件的处理转交给 id 为 babel 的HappyPack实例
          use:['happypack/loader?id=babel'],
          include: [resolve('src'), resolve('test'),   
            resolve('node_modules/webpack-dev-server/client')],
        // 排除第三方插件
          exclude:path.resolve(__dirname,'node_modules'),
        },
        {
          test: /\.vue$/,
          use: ['happypack/loader?id=vue'],
        },
      ]
    },
</code></pre></div><ol start="3"><li>webpack.prod.conf.js 文件进行配置</li></ol> <div class="language- extra-class"><pre class="language-text"><code>    const HappyPack = require('happypack');
    // 构造出共享进程池，在进程池中包含5个子进程
    const HappyPackThreadPool = HappyPack.ThreadPool({size:5});
    plugins: [
       new HappyPack({
         // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件
         id:'vue',
         loaders:[
           {
             loader:'vue-loader',
             options: vueLoaderConfig
           }
         ],
         threadPool: HappyPackThreadPool,
       }),

       new HappyPack({
         // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件
         id:'babel',
         // 如何处理.js文件，用法和Loader配置中一样
         loaders:['babel-loader?cacheDirectory'],
         threadPool: HappyPackThreadPool,
       }),
    ]
</code></pre></div><h2 id="_4-使用paralleluglifyplugin多进程压缩代码文件"><a href="#_4-使用paralleluglifyplugin多进程压缩代码文件" class="header-anchor">#</a> 4. 使用ParallelUglifyPlugin多进程压缩代码文件</h2> <p>由于压缩JavaScript 代码时，需要先将代码<code>解析</code>成用 Object 抽象表示的 <code>AST</code> 语法树，再去应用各种规则分析和处理AST ，所以导致这个过程的计算量巨大，耗时非常多。</p> <p>当Webpack有多个JavaScript 文件需要输出和压缩时，原本会使用<code>UglifyJS</code>去一个一个<code>压缩再输出</code>。如果使用ParallelUglifyPlugin会开启<code>多个子进程</code>，将对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过UglifyJS去压缩代码，但是变成了<code>并行执行</code>。</p> <p>所以 ParallelUglify Plugin能更快地完成对多个文件的压缩工作。</p> <p><strong>项目中ParallelUglifyPlugin使用配置：</strong></p> <ol><li>ParallelUglifyPlugin插件安装：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>     $ npm i -D webpack-parallel-uglify-plugin
</code></pre></div><ol start="2"><li>webpack.prod.conf.js 文件进行配置</li></ol> <div class="language- extra-class"><pre class="language-text"><code>    const ParallelUglifyPlugin =require('webpack-parallel-uglify-plugin');
    plugins: [
    new ParallelUglifyPlugin({
      cacheDir: '.cache/',
      uglifyJs:{
        compress: {
          warnings: false
        },
        sourceMap: true
      }
     }),
    ]
</code></pre></div><h2 id="_5-使用自动刷新"><a href="#_5-使用自动刷新" class="header-anchor">#</a> 5. 使用自动刷新</h2> <p>借助自动化的手段，在监听到本地源码文件发生变化时，<code>自动重新构建</code>出<code>可运行</code>的代码后<code>再控制</code>浏览器刷新。</p> <p>Webpack将这些功能都<code>内置</code>了，并且提供了多种方案供我们选择。</p> <p><strong>项目中自动刷新的配置：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>devServer: {
  watchOptions: {
    // 不监听的文件或文件夹，支持正则匹配
    ignored: /node_modules/,
    // 监听到变化后等300ms再去执行动作
    aggregateTimeout: 300,
    // 默认每秒询问1000次
    poll: 1000
  }
},
</code></pre></div><p><strong>相关优化措施：</strong></p> <ul><li>配置忽略一些不监听的一些文件，如：node_modules。</li> <li>watchOptions.aggregateTirneout 的值越大性能越好，因为这能降低重新构建的频率。</li> <li>watchOptions.poll 的值越小越好，因为这能降低检查的频率。</li></ul> <h2 id="_6-开启模块热替换"><a href="#_6-开启模块热替换" class="header-anchor">#</a> 6. 开启模块热替换</h2> <p>DevServer 还支持一种叫做模块热替换（ Hot Module Replacement ）的技术可在不刷新整个网页的情况下做到超灵敏实时预览。</p> <p>原理是在一个<code>源码</code>发生<code>变化</code>时，只需<code>重新编译</code>发生<code>变化的模块</code>，再用<code>新输出</code>的模块<code>替换</code>掉浏览器中对应的<code>老模块</code> 。</p> <p>模块热替换技术在很大程度上提升了开发效率和体验 。 
<strong>项目中模块热替换的配置：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>devServer: {
  hot: true,
},
plugins: [
  new webpack.HotModuleReplacementPlugin(),
// 显示被替换模块的名称
  new webpack.NamedModulesPlugin(), // HMR shows correct file names
]
</code></pre></div><h2 id="_7-提取公共代码"><a href="#_7-提取公共代码" class="header-anchor">#</a> 7. 提取公共代码</h2> <p>如果每个页面的代码都将这些公共的部分包含进去，则会造成以下问题 ：</p> <ol><li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li> <li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</li></ol> <p>如果将多个页面的公共代码抽离成单独的文件，就能优化以上问题 。</p> <p>Webpack内置了专门用于<code>提取多个Chunk</code>中的<code>公共部分</code>的插件<code>CommonsChunkPlugin</code>。</p> <p><strong>CommonsChunkPlugin的配置属性：</strong></p> <ul><li>name：可以是已经存在的chunk（一般指入口文件）对应的name，那么就会把公共模块代码合并到这个chunk上；否则，会创建名字为name的commons chunk进行合并</li> <li>filename：指定commons chunk的文件名</li> <li>chunks：指定source chunk，即指定从哪些chunk当中去找公共模块，省略该选项的时候，默认就是entry chunks</li> <li>minChunks：既可以是数字，也可以是函数，还可以是Infinity，具体用法和区别下面会说</li></ul> <p><strong>实例：</strong>
分离出第三方库、自定义公共模块、webpack运行文件，first.js和second.js都引入了jquery和common.js</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require(&quot;path&quot;);
const webpack = require(&quot;webpack&quot;);
const packagejson = require(&quot;./package.json&quot;);

const config = {
    entry: {
        first: './src/first.js',
        second: './src/second.js',
        vendor: Object.keys(packagejson.dependencies)//获取生产环境依赖的库
    },
    output: {
        path: path.resolve(__dirname,'./dist'),
        filename: '[name].js'
    },
    plugins: [
        new webpack.optimize.CommonsChunkPlugin({
            name: 'vendor',
            filename: '[name].js'
        }),
    ]
}

module.exports = config;
</code></pre></div><p>查看dist目录下，新增了一个vendor.js的文件</p> <p><a data-fancybox="" title="打包图片" href="/loader3.webp"><img src="/loader3.webp" alt="order"></a>
此时：first.js和second.js文件中依赖的jquery和common.js都被打包进vendor.js中，同时还有webpack的运行文件。</p> <p><a href="https://segmentfault.com/a/1190000012828879" target="_blank" rel="noopener noreferrer">详情访问此文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_8-通过webpack-bundle-analyzer分析代码包的大小"><a href="#_8-通过webpack-bundle-analyzer分析代码包的大小" class="header-anchor">#</a> 8. 通过webpack-bundle-analyzer分析代码包的大小</h3> <blockquote><p>它可以直观分析打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项，文件是否重复，压缩后大小如何，针对这些，我们可以进行文件分割等操作。</p></blockquote> <ol><li>安装依赖</li></ol> <p>首先安装webpack-bundle-analyzer</p> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev webpack-bundle-analyzer
</code></pre></div><p>大多数情况下，在windows平台下使用类似于: NODE_ENV=production的命令行指令会卡住。
cross-env能跨平台地设置及使用环境变量</p> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev cross-env
</code></pre></div><ol start="2"><li>配置webpack.config.js文件
在webpack.config.js中配置以下代码</li></ol> <div class="language- extra-class"><pre class="language-text"><code>if (config.build.bundleAnalyzerReport) {
    const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
    /*
    module.exports = {
        plugins: [
            new BundleAnalyzerPlugin()
        ]
    }*/
    webpackConfig.plugins.push(new BundleAnalyzerPlugin())
}
</code></pre></div><ol start="3"><li>运行</li></ol> <p>3.1 开发环境下运行</p> <p>直接启动项目：</p> <div class="language- extra-class"><pre class="language-text"><code>npm run start 则会自动启动项目页面和分析页面（127.0.0.1:8888 默认地址和端口号）
</code></pre></div><p>3.2 打包后运行</p> <p>首先配置package.json</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;scripts&quot;: {
    &quot;analyz&quot;: &quot;cross-env NODE_ENV=production npm_config_report=true npm run build&quot;
}
</code></pre></div><p>运行命令：</p> <div class="language- extra-class"><pre class="language-text"><code>npm run analyz
</code></pre></div><p>项目打包完毕后会自动启动分析页面（127.0.0.1:8888 默认地址和端口号）</p> <h2 id="_9-dll-plugin"><a href="#_9-dll-plugin" class="header-anchor">#</a> 9. DLL  Plugin</h2> <p>在引入一些第三方模块时，例如Vue、React等，这些框架的文件一般都是不会修改的，</p> <p>而每次打包都需要去解析他们，就会影响打包速度，就算是做了拆分，也只是提高了上线后的用户访问速度，并不会提高构建速度，所以如果需要提高构建速度，应该使用<code>动态链接库</code>的方式，类似<code>windows</code>的<code>dll文件</code></p> <p>借助<code>DLLPlugin</code>插件实现将这些框架作为一个个的<code>动态链接库</code>，只构建<code>一次</code>，以后的每次构建都<code>只会</code>生成自己的<code>业务代码</code>，可以很好的提高构建效率</p> <p>主要思想在于，将一些<code>不做修改</code>的<code>依赖文件</code>，<code>提前打包</code>，这样我们开发代码发布的时候就<code>不需要再对</code>这些代码进行<code>打包</code>，从而节省了打包时间。</p> <p>主要使用两个插件: <code>DLLPlugin</code>和<code>DLLReferencePlugin</code></p> <blockquote><p>需要注意的是，若是使用DLLPlugin，CleanWebpackPlugin插件会存在冲突，需要移除CleanWebpackPlugin插件</p></blockquote> <p><strong>DLLPlugin：</strong></p> <p>使用一个单独webpack配置创建一个<code>dll文件</code>，并且它还创建一个<code>manifest.json</code>，</p> <p>DLLReferencePlugin使用<code>该json文件</code>来做<code>映射依赖性</code>，这个文件会告诉webpack哪些文件已经提前打包好了</p> <ul><li><p>配置参数</p> <ul><li>context(可选): manifest文件中请求的上下文，默认为该webpack文件上下文</li> <li>name: 公开的dll函数的名称，和output.library保持一致即可</li> <li>path: manifest.json 生成的文件夹及名称</li></ul></li></ul> <p><strong>DLLReferencePlugin：</strong></p> <p>该插件主要用于主webpack配置，它引用的dll需要预先构建的依赖该系</p> <ul><li><p>配置参数</p> <ul><li>context: manifest文件中的请求上下文</li> <li>manifest: DLLPlugin插件生成的manifest.</li> <li>jsoncontent(可选): 请求的映射模块id(默认为manifest.content)</li> <li>name(可选): dll暴露的名称</li> <li>scope(可选): 前缀用于访问dll的文件</li> <li>sourceType(可选): dll是如何暴露(libraryTarget)</li></ul></li></ul> <p><strong>将VUE项目中的库抽取成DLL:</strong></p> <ol><li>准备一份将VUE打包成DLL的<code>webpack配置文件</code>。</li></ol> <ul><li>在<code>build</code>目录下新建一个文件<code>webpack.vue.js</code>，专门用于打包vue的DLL的。</li> <li>配置入口：将多个要做成dll的库全放进来</li> <li>配置出口：一定要设置library属性，将打包好的结果暴露在全局</li> <li>配置plugin：设置打包后dll文件名和manifest文件所在地</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 此配置文件 是打包VUE全家桶的
const path = require('path')
const webpack = require('webpack')

module.exports = {
  mode: 'production',
  entry:{
    vue: [ 
      'vue/dist/vue',
      'vue-router'
    ]
  },
  output:{
    path: path.resolve(__dirname, '../dist'),
    filename: '[name]_dll.js',
    library: '[name]_dll' // 最终会在全局暴露出一个[name]_dll的对象
  },
  plugins:[
    new webpack.DllPlugin({
      name: '[name]_dll',
      path: path.resolve(__dirname, '../dist/manifest.json'),
    })
  ]
}
</code></pre></div><p>webpack.vue.js 只是用来打包生成 [name]_dd.js 文件和 manifest.json文件的，是不需要参与到业务代码打包的，因为只会在每一次修改了需要生成dll文件的时间才会执行一次，否则不需要参与到打包</p> <ol start="2"><li>在webpack.base.js中进行插件的配置</li></ol> <p>使用DllReferencePlugin指定manifest文件的位置即可</p> <div class="language- extra-class"><pre class="language-text"><code>new webpack.DllReferencePlugin({
 manifest: path.resolve(__dirname, '../dist/manifest.json'),
})
</code></pre></div><ol start="3"><li>由于[name]_dll文件生成之后，并没有动态的引入进去，所以需要一个插件可以动态的将生成的dll文件引入</li></ol> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm i -D add-asset-html-webpack-plugin
</code></pre></div><p>配置插件自动添加script标签到HTML中，需要注意的是，必须在HtmlWebpackPlugin后面引入，因为HtmlWebpackPlugin是生产一个html文件，AddAssetHtmlWebpackPlugin是在已有的html中注入一个script，否则会被覆盖</p> <div class="language- extra-class"><pre class="language-text"><code>new AddAssetHtmlWebpackPlugin({
  filepath: path.resolve(__dirname, '../dist/vue_dll.js')
})
</code></pre></div><h2 id="_10-ignore-plugin"><a href="#_10-ignore-plugin" class="header-anchor">#</a> 10. Ignore   Plugin</h2> <blockquote><p>在引入一些第三方模块时，例如momentJS、dayJS，其内部会做i18n处理，所以会包含很多语言包，而语言包打包时会比较占用空间，如果项目只需要用到中文或者少数语言，可以忽略掉所有的语言包，然后按需引入语言包，从而使得构建效率更高，打包生成的文件更小</p></blockquote> <p><strong>以moment为例</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import moment from 'moment'
moment.locale('zh-CN') // 设置为中文

console.log(moment().subtract(6, 'days').calendar())
</code></pre></div><p>首先要找到moment依赖的语言包时什么，通过查看moment的源码来分析</p> <div class="language- extra-class"><pre class="language-text"><code>function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] &amp;&amp; (typeof module !== 'undefined') &amp;&amp;
            module &amp;&amp; module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}
</code></pre></div><p>通过 aliasedRequire('./locale/' + name) 可以知道momentJS的多语言目录是locale，所有的语言JS文件都在这个目录中</p> <p>使用IgnorePlugin插件忽略其依赖</p> <p>将momentJS的多语言目录locale忽略</p> <div class="language- extra-class"><pre class="language-text"><code>new webpack.IgnorePlugin(/\.\/locale/, /moment/)
</code></pre></div><p>需要使用某些依赖时自行手动引入</p> <p>忽略其依赖之后，moment.locale('zh-CN')就会失效，因为其所依赖的语言包全都被忽略了，需要手动将其引入</p> <div class="language- extra-class"><pre class="language-text"><code>import moment from 'moment'
import  'moment/locale/zh-cn' // 需要手动引入方可生效
moment.locale('zh-CN')

console.log(moment().subtract(6, 'days').calendar())
</code></pre></div><h2 id="_11-js优化"><a href="#_11-js优化" class="header-anchor">#</a> 11. JS优化</h2> <blockquote><p><code>code splitting</code> 是webpack打包时用到的重要的优化特性之一</p></blockquote> <p>此特性能够把代码分离到不同的<code>bundle</code>中，然后可以<code>按需加载</code>或者<code>并行加载</code>这些文件，</p> <p><code>代码分离</code>可以用于获取<code>更小</code>的bundle，以及控制资源<code>加载优先级</code>，如果能够合理的使用能够极大影响加载时间</p> <p><strong>三种常见的代码分离方法</strong></p> <ul><li>入口起点：使用entry配置，手动的分离代码</li> <li>放置重复：使用 SplitChunksPlugin 去重和分离 chunk</li> <li>动态导入：通过模块的内联函数调用来分离代码</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/longweixia/tools/git/1.html" class="prev">
        常用操作
      </a></span> <span class="next"><a href="/longweixia/tools/webpack/2.html">
        什么是loader
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/longweixia/assets/js/app.30853e2a.js" defer></script><script src="/longweixia/assets/js/2.19b4ab8a.js" defer></script><script src="/longweixia/assets/js/53.c938b0b0.js" defer></script>
  </body>
</html>
